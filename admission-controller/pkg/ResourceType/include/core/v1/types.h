/***********************************************************************
 * THIS FILE IS GENERATED BY TransformK8sAPI.py, PLEASE DONT MODIFY IT *
 ***********************************************************************/

#ifndef TYPES_H_0200D91C
#define TYPES_H_0200D91C

#include "Marshal.h"
#include "goraw/types.h"
#include "meta/v1/types.h"
namespace apis { namespace core { namespace v1 {
extern const char * LabelHostname;
extern const char * LabelZoneFailureDomain;
extern const char * LabelZoneRegion;
extern const char * LabelZoneFailureDomainStable;
extern const char * LabelZoneRegionStable;
extern const char * LabelInstanceType;
extern const char * LabelInstanceTypeStable;
extern const char * LabelOSStable;
extern const char * LabelArchStable;
// LabelWindowsBuild is used on Windows nodes to specify the Windows build number starting with v1.17.0.
// It's in the format MajorVersion.MinorVersion.BuildNumber (for ex: 10.0.17763)
extern const char * LabelWindowsBuild;
// LabelNamespaceSuffixKubelet is an allowed label namespace suffix kubelets can self-set ([*.]kubelet.kubernetes.io/*)
extern const char * LabelNamespaceSuffixKubelet;
// LabelNamespaceSuffixNode is an allowed label namespace suffix kubelets can self-set ([*.]node.kubernetes.io/*)
extern const char * LabelNamespaceSuffixNode;
// LabelNamespaceNodeRestriction is a forbidden label namespace that kubelets may not self-set when the NodeRestriction admission plugin is enabled
extern const char * LabelNamespaceNodeRestriction;
// IsHeadlessService is added by Controller to an Endpoint denoting if its parent
// Service is Headless. The existence of this label can be used further by other
// controllers and kube-proxy to check if the Endpoint objects should be replicated when
// using Headless Services
extern const char * IsHeadlessService;
// This file should be consistent with pkg/api/annotation_key_constants.go.
// ImagePolicyFailedOpenKey is added to pods created by failing open when the image policy
// webhook backend fails.
extern const char * ImagePolicyFailedOpenKey;
// PodPresetOptOutAnnotationKey represents the annotation key for a pod to exempt itself from pod preset manipulation
extern const char * PodPresetOptOutAnnotationKey;
// MirrorAnnotationKey represents the annotation key set by kubelets when creating mirror pods
extern const char * MirrorPodAnnotationKey;
// TolerationsAnnotationKey represents the key of tolerations data (json serialized)
// in the Annotations of a Pod.
extern const char * TolerationsAnnotationKey;
// TaintsAnnotationKey represents the key of taints data (json serialized)
// in the Annotations of a Node.
extern const char * TaintsAnnotationKey;
// SeccompPodAnnotationKey represents the key of a seccomp profile applied
// to all containers of a pod.
// Deprecated: set a pod security context `seccompProfile` field.
extern const char * SeccompPodAnnotationKey;
// SeccompContainerAnnotationKeyPrefix represents the key of a seccomp profile applied
// to one container of a pod.
// Deprecated: set a container security context `seccompProfile` field.
extern const char * SeccompContainerAnnotationKeyPrefix;
// SeccompProfileRuntimeDefault represents the default seccomp profile used by container runtime.
// Deprecated: set a pod or container security context `seccompProfile` of type "RuntimeDefault" instead.
extern const char * SeccompProfileRuntimeDefault;
// SeccompProfileNameUnconfined is the unconfined seccomp profile.
extern const char * SeccompProfileNameUnconfined;
// SeccompLocalhostProfileNamePrefix is the prefix for specifying profiles loaded from the node's disk.
extern const char * SeccompLocalhostProfileNamePrefix;
// AppArmorBetaContainerAnnotationKeyPrefix is the prefix to an annotation key specifying a container's apparmor profile.
extern const char * AppArmorBetaContainerAnnotationKeyPrefix;
// AppArmorBetaDefaultProfileAnnotatoinKey is the annotation key specifying the default AppArmor profile.
extern const char * AppArmorBetaDefaultProfileAnnotationKey;
// AppArmorBetaAllowedProfileAnnotationKey is the annotation key specifying the allowed AppArmor profiles.
extern const char * AppArmorBetaAllowedProfilesAnnotationKey;
// AppArmorBetaProfileRuntimeDefault is the profile specifying the runtime default.
extern const char * AppArmorBetaProfileRuntimeDefault;
// AppArmorBetaProfileNamePrefix is the prefix for specifying profiles loaded on the node.
extern const char * AppArmorBetaProfileNamePrefix;
// AppArmorBetaProfileNameUnconfined is the Unconfined AppArmor profile
extern const char * AppArmorBetaProfileNameUnconfined;
// DeprecatedSeccompProfileDockerDefault represents the default seccomp profile used by docker.
// Deprecated: set a pod or container security context `seccompProfile` of type "RuntimeDefault" instead.
extern const char * DeprecatedSeccompProfileDockerDefault;
// PreferAvoidPodsAnnotationKey represents the key of preferAvoidPods data (json serialized)
// in the Annotations of a Node.
extern const char * PreferAvoidPodsAnnotationKey;
// ObjectTTLAnnotations represents a suggestion for kubelet for how long it can cache
// an object (e.g. secret, config map) before fetching it again from apiserver.
// This annotation can be attached to node.
extern const char * ObjectTTLAnnotationKey;
// annotation key prefix used to identify non-convertible json paths.
extern const char * NonConvertibleAnnotationPrefix;
extern const char * kubectlPrefix;
// LastAppliedConfigAnnotation is the annotation used to store the previous
// configuration of a resource for use in a three way diff by UpdateApplyAnnotation.
extern const char * LastAppliedConfigAnnotation;
// AnnotationLoadBalancerSourceRangesKey is the key of the annotation on a service to set allowed ingress ranges on their LoadBalancers
// 
// It should be a comma-separated list of CIDRs, e.g. `0.0.0.0/0` to
// allow full access (the default) or `18.0.0.0/8,56.0.0.0/8` to allow
// access only from the CIDRs currently allocated to MIT & the USPS.
// 
// Not all cloud providers support this annotation, though AWS & GCE do.
extern const char * AnnotationLoadBalancerSourceRangesKey;
// EndpointsLastChangeTriggerTime is the annotation key, set for endpoints objects, that
// represents the timestamp (stored as RFC 3339 date-time string, e.g. '2018-10-22T19:32:52.1Z')
// of the last change, of some Pod or Service object, that triggered the endpoints object change.
// In other words, if a Pod / Service changed at time T0, that change was observed by endpoints
// controller at T1, and the Endpoints object was changed at T2, the
// EndpointsLastChangeTriggerTime would be set to T0.
// 
// The "endpoints change trigger" here means any Pod or Service change that resulted in the
// Endpoints object change.
// 
// Given the definition of the "endpoints change trigger", please note that this annotation will
// be set ONLY for endpoints object changes triggered by either Pod or Service change. If the
// Endpoints object changes due to other reasons, this annotation won't be set (or updated if it's
// already set).
// 
// This annotation will be used to compute the in-cluster network programming latency SLI, see
// https://github.com/kubernetes/community/blob/master/sig-scalability/slos/network_programming_latency.md
extern const char * EndpointsLastChangeTriggerTime;
// EndpointsOverCapacity will be set on an Endpoints resource when it
// exceeds the maximum capacity of 1000 addresses. Inititially the Endpoints
// controller will set this annotation with a value of "warning". In a
// future release, the controller may set this annotation with a value of
// "truncated" to indicate that any addresses exceeding the limit of 1000
// have been truncated from the Endpoints resource.
extern const char * EndpointsOverCapacity;
// MigratedPluginsAnnotationKey is the annotation key, set for CSINode objects, that is a comma-separated
// list of in-tree plugins that will be serviced by the CSI backend on the Node represented by CSINode.
// This annotation is used by the Attach Detach Controller to determine whether to use the in-tree or
// CSI Backend for a volume plugin on a specific node.
extern const char * MigratedPluginsAnnotationKey;
// PodDeletionCost can be used to set to an int32 that represent the cost of deleting
// a pod compared to other pods belonging to the same ReplicaSet. Pods with lower
// deletion cost are preferred to be deleted before pods with higher deletion cost.
// Note that this is honored on a best-effort basis, and so it does not offer guarantees on
// pod deletion order.
// The implicit deletion cost for pods that don't set the annotation is 0, negative values are permitted.
// 
// This annotation is alpha-level and is only honored when PodDeletionCost feature is enabled.
extern const char * PodDeletionCost;
// AnnotationTopologyAwareHints can be used to enable or disable Topology
// Aware Hints for a Service. This may be set to "Auto" or "Disabled". Any
// other value is treated as "Disabled".
extern const char * AnnotationTopologyAwareHints;
// TaintNodeNotReady will be added when node is not ready
// and removed when node becomes ready.
extern const char * TaintNodeNotReady;
// TaintNodeUnreachable will be added when node becomes unreachable
// (corresponding to NodeReady status ConditionUnknown)
// and removed when node becomes reachable (NodeReady status ConditionTrue).
extern const char * TaintNodeUnreachable;
// TaintNodeUnschedulable will be added when node becomes unschedulable
// and removed when node becomes scheduable.
extern const char * TaintNodeUnschedulable;
// TaintNodeMemoryPressure will be added when node has memory pressure
// and removed when node has enough memory.
extern const char * TaintNodeMemoryPressure;
// TaintNodeDiskPressure will be added when node has disk pressure
// and removed when node has enough disk.
extern const char * TaintNodeDiskPressure;
// TaintNodeNetworkUnavailable will be added when node's network is unavailable
// and removed when network becomes ready.
extern const char * TaintNodeNetworkUnavailable;
// TaintNodePIDPressure will be added when node has pid pressure
// and removed when node has enough disk.
extern const char * TaintNodePIDPressure;
// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
extern const char * NamespaceDefault;
// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
// NamespaceNodeLease is the namespace where we place node lease objects (used for node heartbeats)
extern const char * NamespaceNodeLease;
// BetaStorageClassAnnotation represents the beta/previous StorageClass annotation.
// It's currently still used and will be held for backwards compatibility
extern const char * BetaStorageClassAnnotation;
// MountOptionAnnotation defines mount option annotation used in PVs
extern const char * MountOptionAnnotation;
// PersistentVolumeReclaimRecycle means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim.
// The volume plugin must support Recycling.
extern const char * PersistentVolumeReclaimRecycle;
// PersistentVolumeReclaimDelete means the volume will be deleted from Kubernetes on release from its claim.
// The volume plugin must support Deletion.
extern const char * PersistentVolumeReclaimDelete;
// PersistentVolumeReclaimRetain means the volume will be left in its current phase (Released) for manual reclamation by the administrator.
// The default policy is Retain.
extern const char * PersistentVolumeReclaimRetain;
// PersistentVolumeBlock means the volume will not be formatted with a filesystem and will remain a raw block device.
extern const char * PersistentVolumeBlock;
// PersistentVolumeFilesystem means the volume will be or is formatted with a filesystem.
extern const char * PersistentVolumeFilesystem;
// PersistentVolumeClaimResizing - a user trigger resize of pvc has been started
extern const char * PersistentVolumeClaimResizing;
// PersistentVolumeClaimFileSystemResizePending - controller resize is finished and a file system resize is pending on node
extern const char * PersistentVolumeClaimFileSystemResizePending;
// can be mounted in read/write mode to exactly 1 host
extern const char * ReadWriteOnce;
// can be mounted in read-only mode to many hosts
extern const char * ReadOnlyMany;
// can be mounted in read/write mode to many hosts
extern const char * ReadWriteMany;
// used for PersistentVolumes that are not available
extern const char * VolumePending;
// used for PersistentVolumes that are not yet bound
// Available volumes are held by the binder and matched to PersistentVolumeClaims
extern const char * VolumeAvailable;
// used for PersistentVolumes that are bound
extern const char * VolumeBound;
// used for PersistentVolumes where the bound PersistentVolumeClaim was deleted
// released volumes must be recycled before becoming available again
// this phase is used by the persistent volume claim binder to signal to another process to reclaim the resource
extern const char * VolumeReleased;
// used for PersistentVolumes that failed to be correctly recycled or deleted after being released from a claim
extern const char * VolumeFailed;
// used for PersistentVolumeClaims that are not yet bound
extern const char * ClaimPending;
// used for PersistentVolumeClaims that are bound
extern const char * ClaimBound;
// used for PersistentVolumeClaims that lost their underlying
// PersistentVolume. The claim was bound to a PersistentVolume and this
// volume does not exist any longer and all data on it was lost.
extern const char * ClaimLost;
// For backwards compatible, leave it empty if unset
// If nothing exists at the given path, an empty directory will be created there
// as needed with file mode 0755, having the same group and ownership with Kubelet.
extern const char * HostPathDirectoryOrCreate;
// A directory must exist at the given path
extern const char * HostPathDirectory;
// If nothing exists at the given path, an empty file will be created there
// as needed with file mode 0644, having the same group and ownership with Kubelet.
extern const char * HostPathFileOrCreate;
// A file must exist at the given path
extern const char * HostPathFile;
// A UNIX socket must exist at the given path
extern const char * HostPathSocket;
// A character device must exist at the given path
extern const char * HostPathCharDev;
// A block device must exist at the given path
extern const char * HostPathBlockDev;
// use whatever the default is for the node, assume anything we don't explicitly handle is this
// use memory (e.g. tmpfs on linux)
extern const char * StorageMediumMemory;
// use hugepages
extern const char * StorageMediumHugePages;
// prefix for full medium notation HugePages-<size>
extern const char * StorageMediumHugePagesPrefix;
// ProtocolTCP is the TCP protocol.
extern const char * ProtocolTCP;
// ProtocolUDP is the UDP protocol.
extern const char * ProtocolUDP;
// ProtocolSCTP is the SCTP protocol.
extern const char * ProtocolSCTP;
extern const long SecretVolumeSourceDefaultMode;
extern const char * AzureDataDiskCachingNone;
extern const char * AzureDataDiskCachingReadOnly;
extern const char * AzureDataDiskCachingReadWrite;
extern const char * AzureSharedBlobDisk;
extern const char * AzureDedicatedBlobDisk;
extern const char * AzureManagedDisk;
extern const long ConfigMapVolumeSourceDefaultMode;
extern const long ProjectedVolumeSourceDefaultMode;
// MountPropagationNone means that the volume in a container will
// not receive new mounts from the host or other containers, and filesystems
// mounted inside the container won't be propagated to the host or other
// containers.
// Note that this mode corresponds to "private" in Linux terminology.
extern const char * MountPropagationNone;
// MountPropagationHostToContainer means that the volume in a container will
// receive new mounts from the host or other containers, but filesystems
// mounted inside the container won't be propagated to the host or other
// containers.
// Note that this mode is recursively applied to all mounts in the volume
// ("rslave" in Linux terminology).
extern const char * MountPropagationHostToContainer;
// MountPropagationBidirectional means that the volume in a container will
// receive new mounts from the host or other containers, and its own mounts
// will be propagated from the container to the host or other containers.
// Note that this mode is recursively applied to all mounts in the volume
// ("rshared" in Linux terminology).
extern const char * MountPropagationBidirectional;
// URISchemeHTTP means that the scheme used will be http://
extern const char * URISchemeHTTP;
// URISchemeHTTPS means that the scheme used will be https://
extern const char * URISchemeHTTPS;
// PullAlways means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
extern const char * PullAlways;
// PullNever means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
extern const char * PullNever;
// PullIfNotPresent means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
extern const char * PullIfNotPresent;
// PreemptLowerPriority means that pod can preempt other pods with lower priority.
extern const char * PreemptLowerPriority;
// PreemptNever means that pod never preempts other pods with lower priority.
extern const char * PreemptNever;
// TerminationMessageReadFile is the default behavior and will set the container status message to
// the contents of the container's terminationMessagePath when the container exits.
extern const char * TerminationMessageReadFile;
// TerminationMessageFallbackToLogsOnError will read the most recent contents of the container logs
// for the container status message when the container exits with an error and the
// terminationMessagePath has no contents.
extern const char * TerminationMessageFallbackToLogsOnError;
// TerminationMessagePathDefault means the default path to capture the application termination message running in a container
extern const char * TerminationMessagePathDefault;
// These are valid condition statuses. "ConditionTrue" means a resource is in the condition.
// "ConditionFalse" means a resource is not in the condition. "ConditionUnknown" means kubernetes
// can't decide if a resource is in the condition or not. In the future, we could add other
// intermediate conditions, e.g. ConditionDegraded.
extern const char * ConditionTrue;
extern const char * ConditionFalse;
extern const char * ConditionUnknown;
// These are the valid statuses of pods.
// PodPending means the pod has been accepted by the system, but one or more of the containers
// has not been started. This includes time before being bound to a node, as well as time spent
// pulling images onto the host.
extern const char * PodPending;
// PodRunning means the pod has been bound to a node and all of the containers have been started.
// At least one container is still running or is in the process of being restarted.
extern const char * PodRunning;
// PodSucceeded means that all containers in the pod have voluntarily terminated
// with a container exit code of 0, and the system is not going to restart any of these containers.
extern const char * PodSucceeded;
// PodFailed means that all containers in the pod have terminated, and at least one container has
// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
extern const char * PodFailed;
// PodUnknown means that for some reason the state of the pod could not be obtained, typically due
// to an error in communicating with the host of the pod.
extern const char * PodUnknown;
// These are valid conditions of pod.
// ContainersReady indicates whether all containers in the pod are ready.
extern const char * ContainersReady;
// PodInitialized means that all init containers in the pod have started successfully.
extern const char * PodInitialized;
// PodReady means the pod is able to service requests and should be added to the
// load balancing pools of all matching services.
extern const char * PodReady;
// PodScheduled represents status of the scheduling process for this pod.
extern const char * PodScheduled;
// These are reasons for a pod's transition to a condition.
// PodReasonUnschedulable reason in PodScheduled PodCondition means that the scheduler
// can't schedule the pod right now, for example due to insufficient resources in the cluster.
extern const char * PodReasonUnschedulable;
extern const char * RestartPolicyAlways;
extern const char * RestartPolicyOnFailure;
extern const char * RestartPolicyNever;
// DNSClusterFirstWithHostNet indicates that the pod should use cluster DNS
// first, if it is available, then fall back on the default
// (as determined by kubelet) DNS settings.
extern const char * DNSClusterFirstWithHostNet;
// DNSClusterFirst indicates that the pod should use cluster DNS
// first unless hostNetwork is true, if it is available, then
// fall back on the default (as determined by kubelet) DNS settings.
extern const char * DNSClusterFirst;
// DNSDefault indicates that the pod should use the default (as
// determined by kubelet) DNS settings.
extern const char * DNSDefault;
// DNSNone indicates that the pod should use empty DNS settings. DNS
// parameters such as nameservers and search paths should be defined via
// DNSConfig.
extern const char * DNSNone;
// DefaultTerminationGracePeriodSeconds indicates the default duration in
// seconds a pod needs to terminate gracefully.
extern const long DefaultTerminationGracePeriodSeconds;
extern const char * NodeSelectorOpIn;
extern const char * NodeSelectorOpNotIn;
extern const char * NodeSelectorOpExists;
extern const char * NodeSelectorOpDoesNotExist;
extern const char * NodeSelectorOpGt;
extern const char * NodeSelectorOpLt;
// Do not allow new pods to schedule onto the node unless they tolerate the taint,
// but allow all pods submitted to Kubelet without going through the scheduler
// to start, and allow all already-running pods to continue running.
// Enforced by the scheduler.
extern const char * TaintEffectNoSchedule;
// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
// new pods onto the node, rather than prohibiting new pods from scheduling
// onto the node entirely. Enforced by the scheduler.
extern const char * TaintEffectPreferNoSchedule;
// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
// Like TaintEffectNoSchedule, but additionally do not allow pods submitted to
// Kubelet without going through the scheduler to start.
// Enforced by Kubelet and the scheduler.
// TaintEffectNoScheduleNoAdmit TaintEffect = "NoScheduleNoAdmit"
// Evict any already-running pods that do not tolerate the taint.
// Currently enforced by NodeController.
extern const char * TaintEffectNoExecute;
extern const char * TolerationOpExists;
extern const char * TolerationOpEqual;
// DoNotSchedule instructs the scheduler not to schedule the pod
// when constraints are not satisfied.
extern const char * DoNotSchedule;
// ScheduleAnyway instructs the scheduler to schedule the pod
// even if constraints are not satisfied.
extern const char * ScheduleAnyway;
// The default value for enableServiceLinks attribute.
extern const bool DefaultEnableServiceLinks;
// FSGroupChangeOnRootMismatch indicates that volume's ownership and permissions will be changed
// only when permission and ownership of root directory does not match with expected
// permissions on the volume. This can help shorten the time it takes to change
// ownership and permissions of a volume.
extern const char * FSGroupChangeOnRootMismatch;
// FSGroupChangeAlways indicates that volume's ownership and permissions
// should always be changed whenever volume is mounted inside a Pod. This the default
// behavior.
extern const char * FSGroupChangeAlways;
// SeccompProfileTypeUnconfined indicates no seccomp profile is applied (A.K.A. unconfined).
extern const char * SeccompProfileTypeUnconfined;
// SeccompProfileTypeRuntimeDefault represents the default container runtime seccomp profile.
extern const char * SeccompProfileTypeRuntimeDefault;
// SeccompProfileTypeLocalhost indicates a profile defined in a file on the node should be used.
// The file's location is based off the kubelet's deprecated flag --seccomp-profile-root.
// Once the flag support is removed the location will be <kubelet-root-dir>/seccomp.
extern const char * SeccompProfileTypeLocalhost;
// PodQOSGuaranteed is the Guaranteed qos class.
extern const char * PodQOSGuaranteed;
// PodQOSBurstable is the Burstable qos class.
extern const char * PodQOSBurstable;
// PodQOSBestEffort is the BestEffort qos class.
extern const char * PodQOSBestEffort;
// These are valid conditions of a replication controller.
// ReplicationControllerReplicaFailure is added in a replication controller when one of its pods
// fails to be created due to insufficient quota, limit ranges, pod security policy, node selectors,
// etc. or deleted due to kubelet being down or finalizers are failing.
extern const char * ReplicationControllerReplicaFailure;
// ServiceAffinityClientIP is the Client IP based.
extern const char * ServiceAffinityClientIP;
// ServiceAffinityNone - no session affinity.
extern const char * ServiceAffinityNone;
// ServiceTypeClusterIP means a service will only be accessible inside the
// cluster, via the cluster IP.
extern const char * ServiceTypeClusterIP;
// ServiceTypeNodePort means a service will be exposed on one port of
// every node, in addition to 'ClusterIP' type.
extern const char * ServiceTypeNodePort;
// ServiceTypeLoadBalancer means a service will be exposed via an
// external load balancer (if the cloud provider supports it), in addition
// to 'NodePort' type.
extern const char * ServiceTypeLoadBalancer;
// ServiceTypeExternalName means a service consists of only a reference to
// an external name that kubedns or equivalent will return as a CNAME
// record, with no exposing or proxying of any pods involved.
extern const char * ServiceTypeExternalName;
// ServiceExternalTrafficPolicyTypeLocal specifies node-local endpoints behavior.
extern const char * ServiceExternalTrafficPolicyTypeLocal;
// ServiceExternalTrafficPolicyTypeCluster specifies node-global (legacy) behavior.
extern const char * ServiceExternalTrafficPolicyTypeCluster;
// IPv4Protocol indicates that this IP is IPv4 protocol
extern const char * IPv4Protocol;
// IPv6Protocol indicates that this IP is IPv6 protocol
extern const char * IPv6Protocol;
// MaxServiceTopologyKeys is the largest number of topology keys allowed on a service
extern const long MaxServiceTopologyKeys;
// ClusterIPNone - do not assign a cluster IP
// no proxying required and no environment variables should be created for pods
extern const char * ClusterIPNone;
// These are the valid phases of node.
// NodePending means the node has been created/added by the system, but not configured.
extern const char * NodePending;
// NodeRunning means the node has been configured and has Kubernetes components running.
extern const char * NodeRunning;
// NodeTerminated means the node has been removed from the cluster.
extern const char * NodeTerminated;
// These are valid conditions of node. Currently, we don't have enough information to decide
// node condition. In the future, we will add more. The proposed set of conditions are:
// NodeReachable, NodeLive, NodeReady, NodeSchedulable, NodeRunnable.
// NodeReady means kubelet is healthy and ready to accept pods.
extern const char * NodeReady;
// NodeMemoryPressure means the kubelet is under pressure due to insufficient available memory.
extern const char * NodeMemoryPressure;
// NodeDiskPressure means the kubelet is under pressure due to insufficient available disk.
extern const char * NodeDiskPressure;
// NodePIDPressure means the kubelet is under pressure due to insufficient available PID.
extern const char * NodePIDPressure;
// NodeNetworkUnavailable means that network for the node is not correctly configured.
extern const char * NodeNetworkUnavailable;
// These are valid address type of node.
extern const char * NodeHostName;
extern const char * NodeExternalIP;
extern const char * NodeInternalIP;
extern const char * NodeExternalDNS;
extern const char * NodeInternalDNS;
// Resource names must be not more than 63 characters, consisting of upper- or lower-case alphanumeric characters,
// with the -, _, and . characters allowed anywhere, except the first or last character.
// The default convention, matching that for annotations, is to use lower-case names, with dashes, rather than
// camel case, separating compound words.
// Fully-qualified resource typenames are constructed from a DNS-style subdomain, followed by a slash `/` and a name.
// CPU, in cores. (500m = .5 cores)
extern const char * ResourceCPU;
// Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
extern const char * ResourceMemory;
// Volume size, in bytes (e,g. 5Gi = 5GiB = 5 * 1024 * 1024 * 1024)
extern const char * ResourceStorage;
// Local ephemeral storage, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
// The resource name for ResourceEphemeralStorage is alpha and it can change across releases.
extern const char * ResourceEphemeralStorage;
// Default namespace prefix.
extern const char * ResourceDefaultNamespacePrefix;
// Name prefix for huge page resources (alpha).
extern const char * ResourceHugePagesPrefix;
// Name prefix for storage resource limits
extern const char * ResourceAttachableVolumesPrefix;
// These are internal finalizer values to Kubernetes, must be qualified name unless defined here or
// in metav1.
extern const char * FinalizerKubernetes;
// These are the valid phases of a namespace.
// NamespaceActive means the namespace is available for use in the system
extern const char * NamespaceActive;
// NamespaceTerminating means the namespace is undergoing graceful termination
extern const char * NamespaceTerminating;
// NamespaceTerminatingCause is returned as a defaults.cause item when a change is
// forbidden due to the namespace being terminated.
extern const char * NamespaceTerminatingCause;
// These are valid conditions of a namespace.
// NamespaceDeletionDiscoveryFailure contains information about namespace deleter errors during resource discovery.
extern const char * NamespaceDeletionDiscoveryFailure;
// NamespaceDeletionContentFailure contains information about namespace deleter errors during deletion of resources.
extern const char * NamespaceDeletionContentFailure;
// NamespaceDeletionGVParsingFailure contains information about namespace deleter errors parsing GV for legacy types.
extern const char * NamespaceDeletionGVParsingFailure;
// NamespaceContentRemaining contains information about resources remaining in a namespace.
extern const char * NamespaceContentRemaining;
// NamespaceFinalizersRemaining contains information about which finalizers are on resources remaining in a namespace.
extern const char * NamespaceFinalizersRemaining;
// Valid values for event types (new types could be added in future)
// Information only and will not cause any problems
extern const char * EventTypeNormal;
// These events are to warn that something might go wrong
extern const char * EventTypeWarning;
// Limit that applies to all pods in a namespace
extern const char * LimitTypePod;
// Limit that applies to all containers in a namespace
extern const char * LimitTypeContainer;
// Limit that applies to all persistent volume claims in a namespace
extern const char * LimitTypePersistentVolumeClaim;
// The following identify resource constants for Kubernetes object types
// Pods, number
extern const char * ResourcePods;
// Services, number
extern const char * ResourceServices;
// ReplicationControllers, number
extern const char * ResourceReplicationControllers;
// ResourceQuotas, number
extern const char * ResourceQuotas;
// ResourceSecrets, number
extern const char * ResourceSecrets;
// ResourceConfigMaps, number
extern const char * ResourceConfigMaps;
// ResourcePersistentVolumeClaims, number
extern const char * ResourcePersistentVolumeClaims;
// ResourceServicesNodePorts, number
extern const char * ResourceServicesNodePorts;
// ResourceServicesLoadBalancers, number
extern const char * ResourceServicesLoadBalancers;
// CPU request, in cores. (500m = .5 cores)
extern const char * ResourceRequestsCPU;
// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
extern const char * ResourceRequestsMemory;
// Storage request, in bytes
extern const char * ResourceRequestsStorage;
// Local ephemeral storage request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
extern const char * ResourceRequestsEphemeralStorage;
// CPU limit, in cores. (500m = .5 cores)
extern const char * ResourceLimitsCPU;
// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
extern const char * ResourceLimitsMemory;
// Local ephemeral storage limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
extern const char * ResourceLimitsEphemeralStorage;
// The following identify resource prefix for Kubernetes object types
// HugePages request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
// As burst is not supported for HugePages, we would only quota its request, and ignore the limit.
extern const char * ResourceRequestsHugePagesPrefix;
// Default resource requests prefix
extern const char * DefaultResourceRequestsPrefix;
// Match all pod objects where spec.activeDeadlineSeconds
extern const char * ResourceQuotaScopeTerminating;
// Match all pod objects where !spec.activeDeadlineSeconds
extern const char * ResourceQuotaScopeNotTerminating;
// Match all pod objects that have best effort quality of service
extern const char * ResourceQuotaScopeBestEffort;
// Match all pod objects that do not have best effort quality of service
extern const char * ResourceQuotaScopeNotBestEffort;
// Match all pod objects that have priority class mentioned
extern const char * ResourceQuotaScopePriorityClass;
extern const char * ScopeSelectorOpIn;
extern const char * ScopeSelectorOpNotIn;
extern const char * ScopeSelectorOpExists;
extern const char * ScopeSelectorOpDoesNotExist;
// SecretTypeOpaque is the default. Arbitrary user-defined data
extern const char * SecretTypeOpaque;
// SecretTypeServiceAccountToken contains a token that identifies a service account to the API
// 
// Required fields:
// - Secret.Annotations["kubernetes.io/service-account.name"] - the name of the ServiceAccount the token identifies
// - Secret.Annotations["kubernetes.io/service-account.uid"] - the UID of the ServiceAccount the token identifies
// - Secret.Data["token"] - a token that identifies the service account to the API
extern const char * SecretTypeServiceAccountToken;
// ServiceAccountNameKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
extern const char * ServiceAccountNameKey;
// ServiceAccountUIDKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
extern const char * ServiceAccountUIDKey;
// ServiceAccountTokenKey is the key of the required data for SecretTypeServiceAccountToken secrets
extern const char * ServiceAccountTokenKey;
// ServiceAccountKubeconfigKey is the key of the optional kubeconfig data for SecretTypeServiceAccountToken secrets
extern const char * ServiceAccountKubeconfigKey;
// ServiceAccountRootCAKey is the key of the optional root certificate authority for SecretTypeServiceAccountToken secrets
extern const char * ServiceAccountRootCAKey;
// ServiceAccountNamespaceKey is the key of the optional namespace to use as the default for namespaced API calls
extern const char * ServiceAccountNamespaceKey;
// SecretTypeDockercfg contains a dockercfg file that follows the same format rules as ~/.dockercfg
// 
// Required fields:
// - Secret.Data[".dockercfg"] - a serialized ~/.dockercfg file
extern const char * SecretTypeDockercfg;
// DockerConfigKey is the key of the required data for SecretTypeDockercfg secrets
extern const char * DockerConfigKey;
// SecretTypeDockerConfigJson contains a dockercfg file that follows the same format rules as ~/.docker/config.json
// 
// Required fields:
// - Secret.Data[".dockerconfigjson"] - a serialized ~/.docker/config.json file
extern const char * SecretTypeDockerConfigJson;
// DockerConfigJsonKey is the key of the required data for SecretTypeDockerConfigJson secrets
extern const char * DockerConfigJsonKey;
// SecretTypeBasicAuth contains data needed for basic authentication.
// 
// Required at least one of fields:
// - Secret.Data["username"] - username used for authentication
// - Secret.Data["password"] - password or token needed for authentication
extern const char * SecretTypeBasicAuth;
// BasicAuthUsernameKey is the key of the username for SecretTypeBasicAuth secrets
extern const char * BasicAuthUsernameKey;
// BasicAuthPasswordKey is the key of the password or token for SecretTypeBasicAuth secrets
extern const char * BasicAuthPasswordKey;
// SecretTypeSSHAuth contains data needed for SSH authetication.
// 
// Required field:
// - Secret.Data["ssh-privatekey"] - private SSH key needed for authentication
extern const char * SecretTypeSSHAuth;
// SSHAuthPrivateKey is the key of the required SSH private key for SecretTypeSSHAuth secrets
extern const char * SSHAuthPrivateKey;
// SecretTypeTLS contains information about a TLS client or server secret. It
// is primarily used with TLS termination of the Ingress resource, but may be
// used in other types.
// 
// Required fields:
// - Secret.Data["tls.key"] - TLS private key.
// Secret.Data["tls.crt"] - TLS certificate.
// TODO: Consider supporting different formats, specifying CA/destinationCA.
extern const char * SecretTypeTLS;
// TLSCertKey is the key for tls certificates in a TLS secert.
extern const char * TLSCertKey;
// TLSPrivateKeyKey is the key for the private key field in a TLS secret.
extern const char * TLSPrivateKeyKey;
// SecretTypeBootstrapToken is used during the automated bootstrap process (first
// implemented by kubeadm). It stores tokens that are used to sign well known
// ConfigMaps. They are used for authn.
extern const char * SecretTypeBootstrapToken;
// These are the valid conditions for the component.
extern const char * ComponentHealthy;
extern const long DownwardAPIVolumeSourceDefaultMode;
// DefaultProcMount uses the container runtime defaults for readonly and masked
// paths for /proc.  Most container runtimes mask certain paths in /proc to avoid
// accidental security exposure of special devices or information.
extern const char * DefaultProcMount;
// UnmaskedProcMount bypasses the default masking behavior of the container
// runtime and ensures the newly created /proc the container stays in tact with
// no modifications.
extern const char * UnmaskedProcMount;
// "default-scheduler" is the name of default scheduler.
extern const char * DefaultSchedulerName;
// RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
// corresponding to every RequiredDuringScheduling affinity rule.
// When the --hard-pod-affinity-weight scheduler flag is not specified,
// DefaultHardPodAffinityWeight defines the weight of the implicit PreferredDuringScheduling affinity rule.
extern const long DefaultHardPodAffinitySymmetricWeight;
// Enable stdin for remote command execution
extern const char * ExecStdinParam;
// Enable stdout for remote command execution
extern const char * ExecStdoutParam;
// Enable stderr for remote command execution
extern const char * ExecStderrParam;
// Enable TTY for remote command execution
extern const char * ExecTTYParam;
// Command to run for remote command execution
extern const char * ExecCommandParam;
// Name of header that specifies stream type
extern const char * StreamType;
// Value for streamType header for stdin stream
extern const char * StreamTypeStdin;
// Value for streamType header for stdout stream
extern const char * StreamTypeStdout;
// Value for streamType header for stderr stream
extern const char * StreamTypeStderr;
// Value for streamType header for data stream
extern const char * StreamTypeData;
// Value for streamType header for error stream
extern const char * StreamTypeError;
// Value for streamType header for terminal resize stream
extern const char * StreamTypeResize;
// Name of header that specifies the port being forwarded
extern const char * PortHeader;
// Name of header that specifies a request ID used to associate the error
// and data streams for a single forwarded connection
extern const char * PortForwardRequestIDHeader;
// PersistentVolumeReclaimPolicy describes a policy for end-of-life maintenance of persistent volumes.
typedef string PersistentVolumeReclaimPolicy;
// PersistentVolumeMode describes how a volume is intended to be consumed, either Block or Filesystem.
typedef string PersistentVolumeMode;
// PersistentVolumeClaimConditionType is a valid value of PersistentVolumeClaimCondition.Type
typedef string PersistentVolumeClaimConditionType;
typedef string PersistentVolumeAccessMode;
typedef string PersistentVolumePhase;
typedef string PersistentVolumeClaimPhase;
typedef string HostPathType;
// StorageMedium defines ways that storage can be allocated to a volume.
typedef string StorageMedium;
// Protocol defines network protocols supported for things like container ports.
typedef string Protocol;
typedef string AzureDataDiskCachingMode;
typedef string AzureDataDiskKind;
// MountPropagationMode describes mount propagation.
typedef string MountPropagationMode;
// URIScheme identifies the scheme used for connection to a host for Get actions
typedef string URIScheme;
// PullPolicy describes a policy for if/when to pull a container image
typedef string PullPolicy;
// PreemptionPolicy describes a policy for if/when to preempt a pod.
typedef string PreemptionPolicy;
// TerminationMessagePolicy describes how termination messages are retrieved from a container.
typedef string TerminationMessagePolicy;
// Capability represent POSIX capabilities type
typedef string Capability;
typedef string ConditionStatus;
// PodPhase is a label for the condition of a pod at the current time.
typedef string PodPhase;
// PodConditionType is a valid value for PodCondition.Type
typedef string PodConditionType;
// RestartPolicy describes how the container should be restarted.
// Only one of the following restart policies may be specified.
// If none of the following policies is specified, the default one
// is RestartPolicyAlways.
typedef string RestartPolicy;
// DNSPolicy defines how a pod's DNS will be configured.
typedef string DNSPolicy;
// A node selector operator is the set of operators that can be used in
// a node selector requirement.
typedef string NodeSelectorOperator;
typedef string TaintEffect;
// A toleration operator is the set of operators that can be used in a toleration.
typedef string TolerationOperator;
typedef string UnsatisfiableConstraintAction;
// PodFSGroupChangePolicy holds policies that will be used for applying fsGroup to a volume
// when volume is mounted.
typedef string PodFSGroupChangePolicy;
// SeccompProfileType defines the supported seccomp profile types.
typedef string SeccompProfileType;
// PodQOSClass defines the supported qos classes of Pods.
typedef string PodQOSClass;
typedef string ReplicationControllerConditionType;
// Session Affinity Type string
typedef string ServiceAffinity;
// Service Type string describes ingress methods for a service
typedef string ServiceType;
// Service External Traffic Policy Type string
typedef string ServiceExternalTrafficPolicyType;
// IPFamily represents the IP Family (IPv4 or IPv6). This type is used
// to express the family of an IP expressed by a type (i.e. service.Spec.IPFamily)
typedef string IPFamily;
typedef string UniqueVolumeName;
typedef string NodePhase;
typedef string NodeConditionType;
typedef string NodeAddressType;
// ResourceName is the name identifying various resources in a ResourceList.
typedef string ResourceName;
// ResourceList is a set of (resource name, quantity) pairs.
typedef map< ResourceName , apis::goraw::Quantity > ResourceList;
// FinalizerName is the name identifying a finalizer during namespace lifecycle.
typedef string FinalizerName;
typedef string NamespacePhase;
typedef string NamespaceConditionType;
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// List holds a list of objects, which may not be known by the server.
typedef apis::meta::v1::List List;
// LimitType is a type of object that is limited
typedef string LimitType;
// A ResourceQuotaScope defines a filter that must match each object tracked by a quota
typedef string ResourceQuotaScope;
// A scope selector operator is the set of operators that can be used in
// a scope selector requirement.
typedef string ScopeSelectorOperator;
typedef string SecretType;
// Type and constants for component health validation.
typedef string ComponentConditionType;
typedef string ProcMountType;
// NodeResources is an object for conveying resource information about a node.
// see https://kubernetes.io/docs/concepts/architecture/nodes/#capacity for more details.
struct NodeResources {
	NodeResources();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeResources & other) const;
	MARSHAL_JSON;
// Capacity represents the available resources of a node
	ResourceList capacity; // `json:"capacity"`
};
// Sysctl defines a kernel parameter to be set
struct Sysctl {
	Sysctl();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Sysctl & other) const;
	MARSHAL_JSON;
// Name of a property to set
	string name; // `json:"name"`
// Value of a property to set
	string value; // `json:"value"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// RangeAllocation is not a public type.
struct RangeAllocation : public apis::meta::v1::TypeMeta {
	RangeAllocation();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const RangeAllocation & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Range is string that identifies the range represented by 'data'.
	string range; // `json:"range"`
// Data is a bit array containing all allocated addresses in the previous segment.
	vector< char > data; // `json:"data"`
};
// WindowsSecurityContextOptions contain Windows-specific options and credentials.
struct WindowsSecurityContextOptions {
	WindowsSecurityContextOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const WindowsSecurityContextOptions & other) const;
	MARSHAL_JSON;
// GMSACredentialSpecName is the name of the GMSA credential spec to use.
// +optional
	shared_ptr< string > gmsaCredentialSpecName; // `json:"gmsaCredentialSpecName,omitempty"`
// GMSACredentialSpec is where the GMSA admission webhook
// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
// GMSA credential spec named by the GMSACredentialSpecName field.
// +optional
	shared_ptr< string > gmsaCredentialSpec; // `json:"gmsaCredentialSpec,omitempty"`
// The UserName in Windows to run the entrypoint of the container process.
// Defaults to the user specified in image metadata if unspecified.
// May also be set in PodSecurityContext. If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< string > runAsUserName; // `json:"runAsUserName,omitempty"`
};
// SELinuxOptions are the labels to be applied to the container
struct SELinuxOptions {
	SELinuxOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SELinuxOptions & other) const;
	MARSHAL_JSON;
// User is a SELinux user label that applies to the container.
// +optional
	string user; // `json:"user,omitempty"`
// Role is a SELinux role label that applies to the container.
// +optional
	string role; // `json:"role,omitempty"`
// Type is a SELinux type label that applies to the container.
// +optional
	string type; // `json:"type,omitempty"`
// Level is SELinux level label that applies to the container.
// +optional
	string level; // `json:"level,omitempty"`
};
// Information about the condition of a component.
struct ComponentCondition {
	ComponentCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ComponentCondition & other) const;
	MARSHAL_JSON;
// Type of condition for a component.
// Valid value: "Healthy"
	ComponentConditionType type; // `json:"type"`
// Status of the condition for a component.
// Valid values for "Healthy": "True", "False", or "Unknown".
	ConditionStatus status; // `json:"status"`
// Message about the condition for a component.
// For example, information about a health check.
// +optional
	string message; // `json:"message,omitempty"`
// Condition error code for a component.
// For example, a health check error code.
// +optional
	string error; // `json:"error,omitempty"`
};
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
struct ComponentStatus : public apis::meta::v1::TypeMeta {
	ComponentStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ComponentStatus & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// List of component conditions observed
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< ComponentCondition > conditions; // `json:"conditions,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Status of all the conditions for the component as a list of ComponentStatus objects.
struct ComponentStatusList : public apis::meta::v1::TypeMeta, public vector< ComponentStatus > {
	ComponentStatusList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ComponentStatusList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of ComponentStatus objects.
	vector< ComponentStatus > * items; // `json:"items"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ConfigMap holds configuration data for pods to consume.
struct ConfigMap : public apis::meta::v1::TypeMeta {
	ConfigMap();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMap & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Immutable, if set to true, ensures that data stored in the ConfigMap cannot
// be updated (only object metadata can be modified).
// If not set to true, the field can be modified at any time.
// Defaulted to nil.
// This is a beta field enabled by ImmutableEphemeralVolumes feature gate.
// +optional
	shared_ptr< bool > immutable; // `json:"immutable,omitempty"`
// Data contains the configuration data.
// Each key must consist of alphanumeric characters, '-', '_' or '.'.
// Values with non-UTF-8 byte sequences must use the BinaryData field.
// The keys stored in Data must not overlap with the keys in
// the BinaryData field, this is enforced during validation process.
// +optional
	map< string , string > data; // `json:"data,omitempty"`
// BinaryData contains the binary data.
// Each key must consist of alphanumeric characters, '-', '_' or '.'.
// BinaryData can contain byte sequences that are not in the UTF-8 range.
// The keys stored in BinaryData must not overlap with the ones in
// the Data field, this is enforced during validation process.
// Using this field will require 1.10+ apiserver and
// kubelet.
// +optional
	map< string , vector< char > > binaryData; // `json:"binaryData,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ConfigMapList is a resource containing a list of ConfigMap objects.
struct ConfigMapList : public apis::meta::v1::TypeMeta, public vector< ConfigMap > {
	ConfigMapList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapList & other) const;
	MARSHAL_JSON;
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// Items is the list of ConfigMaps.
	vector< ConfigMap > * items; // `json:"items"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Secret holds secret data of a certain type. The total bytes of the values in
// the Data field must be less than MaxSecretSize bytes.
struct Secret : public apis::meta::v1::TypeMeta {
	Secret();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Secret & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Immutable, if set to true, ensures that data stored in the Secret cannot
// be updated (only object metadata can be modified).
// If not set to true, the field can be modified at any time.
// Defaulted to nil.
// This is a beta field enabled by ImmutableEphemeralVolumes feature gate.
// +optional
	shared_ptr< bool > immutable; // `json:"immutable,omitempty"`
// Data contains the secret data. Each key must consist of alphanumeric
// characters, '-', '_' or '.'. The serialized form of the secret data is a
// base64 encoded string, representing the arbitrary (possibly non-string)
// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
// +optional
	map< string , vector< char > > data; // `json:"data,omitempty"`
// stringData allows specifying non-binary secret data in string form.
// It is provided as a write-only convenience method.
// All keys and values are merged into the data field on write, overwriting any existing values.
// It is never output when reading from the API.
// +k8s:conversion-gen=false
// +optional
	map< string , string > stringData; // `json:"stringData,omitempty"`
// Used to facilitate programmatic handling of secret data.
// +optional
	SecretType type; // `json:"type,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// SecretList is a list of Secret.
struct SecretList : public apis::meta::v1::TypeMeta, public vector< Secret > {
	SecretList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// Items is a list of secret objects.
// More info: https://kubernetes.io/docs/concepts/configuration/secret
	vector< Secret > * items; // `json:"items"`
};
// ResourceQuotaStatus defines the enforced hard limits and observed use.
struct ResourceQuotaStatus {
	ResourceQuotaStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceQuotaStatus & other) const;
	MARSHAL_JSON;
// Hard is the set of enforced hard limits for each named resource.
// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
// +optional
	ResourceList hard; // `json:"hard,omitempty"`
// Used is the current observed total usage of the resource in the namespace.
// +optional
	ResourceList used; // `json:"used,omitempty"`
};
// A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
// that relates the scope name and values.
struct ScopedResourceSelectorRequirement {
	ScopedResourceSelectorRequirement();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ScopedResourceSelectorRequirement & other) const;
	MARSHAL_JSON;
// The name of the scope that the selector applies to.
	ResourceQuotaScope scopeName; // `json:"scopeName"`
// Represents a scope's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist.
	ScopeSelectorOperator op; // `json:"operator"`
// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty.
// This array is replaced during a strategic merge patch.
// +optional
	vector< string > values; // `json:"values,omitempty"`
};
// A scope selector represents the AND of the selectors represented
// by the scoped-resource selector requirements.
struct ScopeSelector {
	ScopeSelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ScopeSelector & other) const;
	MARSHAL_JSON;
// A list of scope selector requirements by scope of the resources.
// +optional
	vector< ScopedResourceSelectorRequirement > matchExpressions; // `json:"matchExpressions,omitempty"`
};
// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
struct ResourceQuotaSpec {
	ResourceQuotaSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceQuotaSpec & other) const;
	MARSHAL_JSON;
// hard is the set of desired hard limits for each named resource.
// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
// +optional
	ResourceList hard; // `json:"hard,omitempty"`
// A collection of filters that must match each object tracked by a quota.
// If not specified, the quota matches all objects.
// +optional
	vector< ResourceQuotaScope > scopes; // `json:"scopes,omitempty"`
// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
// but expressed using ScopeSelectorOperator in combination with possible values.
// For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
// +optional
	shared_ptr< ScopeSelector > scopeSelector; // `json:"scopeSelector,omitempty"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ResourceQuota sets aggregate quota restrictions enforced per namespace
struct ResourceQuota : public apis::meta::v1::TypeMeta {
	ResourceQuota();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceQuota & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the desired quota.
// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ResourceQuotaSpec spec; // `json:"spec,omitempty"`
// Status defines the actual enforced quota and its current usage.
// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ResourceQuotaStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ResourceQuotaList is a list of ResourceQuota items.
struct ResourceQuotaList : public apis::meta::v1::TypeMeta, public vector< ResourceQuota > {
	ResourceQuotaList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceQuotaList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// Items is a list of ResourceQuota objects.
// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
	vector< ResourceQuota > * items; // `json:"items"`
};
// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
struct LimitRangeItem {
	LimitRangeItem();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LimitRangeItem & other) const;
	MARSHAL_JSON;
// Type of resource that this limit applies to.
	LimitType type; // `json:"type"`
// Max usage constraints on this kind by resource name.
// +optional
	ResourceList Max; // `json:"max,omitempty"`
// Min usage constraints on this kind by resource name.
// +optional
	ResourceList Min; // `json:"min,omitempty"`
// Default resource requirement limit value by resource name if resource limit is omitted.
// +optional
	ResourceList Default; // `json:"default,omitempty"`
// DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
// +optional
	ResourceList defaultRequest; // `json:"defaultRequest,omitempty"`
// MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
// +optional
	ResourceList maxLimitRequestRatio; // `json:"maxLimitRequestRatio,omitempty"`
};
// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
struct LimitRangeSpec {
	LimitRangeSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LimitRangeSpec & other) const;
	MARSHAL_JSON;
// Limits is the list of LimitRangeItem objects that are enforced.
	vector< LimitRangeItem > limits; // `json:"limits"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// LimitRange sets resource usage limits for each kind of resource in a Namespace.
struct LimitRange : public apis::meta::v1::TypeMeta {
	LimitRange();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LimitRange & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the limits enforced.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	LimitRangeSpec spec; // `json:"spec,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// LimitRangeList is a list of LimitRange items.
struct LimitRangeList : public apis::meta::v1::TypeMeta, public vector< LimitRange > {
	LimitRangeList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LimitRangeList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// Items is a list of LimitRange objects.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	vector< LimitRange > * items; // `json:"items"`
};
// EventSeries contain information on series of events, i.e. thing that was/is happening
// continuously for some time.
struct EventSeries {
	EventSeries();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EventSeries & other) const;
	MARSHAL_JSON;
// Number of occurrences in this series up to the last heartbeat time
	long long count; // `json:"count,omitempty"`
// Time of the last occurrence observed
	apis::meta::v1::MicroTime lastObservedTime; // `json:"lastObservedTime,omitempty"`
};
// EventSource contains information for an event.
struct EventSource {
	EventSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EventSource & other) const;
	MARSHAL_JSON;
// Component from which the event is generated.
// +optional
	string component; // `json:"component,omitempty"`
// Node name on which the event is generated.
// +optional
	string host; // `json:"host,omitempty"`
};
// TypedLocalObjectReference contains enough information to let you locate the
// typed referenced object inside the same namespace.
struct TypedLocalObjectReference {
	TypedLocalObjectReference();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const TypedLocalObjectReference & other) const;
	MARSHAL_JSON;
// APIGroup is the group for the resource being referenced.
// If APIGroup is not specified, the specified Kind must be in the core API group.
// For any other third-party types, APIGroup is required.
// +optional
	shared_ptr< string > apiGroup; // `json:"apiGroup"`
// Kind is the type of resource being referenced
	string kind; // `json:"kind"`
// Name is the name of resource being referenced
	string name; // `json:"name"`
};
// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
struct LocalObjectReference {
	LocalObjectReference();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LocalObjectReference & other) const;
	MARSHAL_JSON;
// Name of the referent.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
// TODO: Add other useful fields. apiVersion, kind, uid?
// +optional
	string name; // `json:"name,omitempty"`
};
// ObjectReference contains enough information to let you inspect or modify the referred object.
// ---
// New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
// 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
// 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
// restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
// Those cannot be well described when embedded.
// 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
// 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
// during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
// and the version of the actual struct is irrelevant.
// 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
// will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
// Instead of using this type, create a locally provided and used type that is well-focused on your reference.
// For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
struct ObjectReference {
	ObjectReference();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ObjectReference & other) const;
	MARSHAL_JSON;
// Kind of the referent.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	string kind; // `json:"kind,omitempty"`
// Namespace of the referent.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
// +optional
	string ns; // `json:"namespace,omitempty"`
// Name of the referent.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
// +optional
	string name; // `json:"name,omitempty"`
// UID of the referent.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
// +optional
	apis::goraw::UID uid; // `json:"uid,omitempty"`
// API version of the referent.
// +optional
	string apiVersion; // `json:"apiVersion,omitempty"`
// Specific resourceVersion to which this reference is made, if any.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
// +optional
	string resourceVersion; // `json:"resourceVersion,omitempty"`
// If referring to a piece of an object instead of an entire object, this string
// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
// For example, if the object reference is to a container within a pod, this would take on a value like:
// "spec.containers{name}" (where "name" refers to the name of the container that triggered
// the event) or if no container name is specified "spec.containers[2]" (container with
// index 2 in this pod). This syntax is chosen only to have some well-defined way of
// referencing a part of an object.
// TODO: this design is not final and this field is subject to change in the future.
// +optional
	string fieldPath; // `json:"fieldPath,omitempty"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Event is a report of an event somewhere in the cluster.
struct Event : public apis::meta::v1::TypeMeta {
	Event();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Event & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata"`
// The object that this event is about.
	ObjectReference involvedObject; // `json:"involvedObject"`
// This should be a short, machine understandable string that gives the reason
// for the transition into the object's current status.
// TODO: provide exact specification for format.
// +optional
	string reason; // `json:"reason,omitempty"`
// A human-readable description of the status of this operation.
// TODO: decide on maximum length.
// +optional
	string message; // `json:"message,omitempty"`
// The component reporting this event. Should be a short machine understandable string.
// +optional
	EventSource source; // `json:"source,omitempty"`
// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
// +optional
	goraw::Time firstTimestamp; // `json:"firstTimestamp,omitempty"`
// The time at which the most recent occurrence of this event was recorded.
// +optional
	goraw::Time lastTimestamp; // `json:"lastTimestamp,omitempty"`
// The number of times this event has occurred.
// +optional
	long long count; // `json:"count,omitempty"`
// Type of this event (Normal, Warning), new types could be added in the future
// +optional
	string type; // `json:"type,omitempty"`
// Time when this Event was first observed.
// +optional
	apis::meta::v1::MicroTime eventTime; // `json:"eventTime,omitempty"`
// Data about the Event series this event represents or nil if it's a singleton Event.
// +optional
	shared_ptr< EventSeries > series; // `json:"series,omitempty"`
// What action was taken/failed regarding to the Regarding object.
// +optional
	string action; // `json:"action,omitempty"`
// Optional secondary object for more complex actions.
// +optional
	shared_ptr< ObjectReference > related; // `json:"related,omitempty"`
// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
// +optional
	string reportingComponent; // `json:"reportingComponent"`
// ID of the controller instance, e.g. `kubelet-xyzf`.
// +optional
	string reportingInstance; // `json:"reportingInstance"`
};
// +k8s:deprecated=state,protobuf=3
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// EventList is a list of events.
struct EventList : public apis::meta::v1::TypeMeta, public vector< Event > {
	EventList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EventList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of events
	vector< Event > * items; // `json:"items"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// SerializedReference is a reference to serialized object.
struct SerializedReference : public apis::meta::v1::TypeMeta {
	SerializedReference();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SerializedReference & other) const;
	MARSHAL_JSON;
// The reference to an object in the system.
// +optional
	ObjectReference reference; // `json:"reference,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ServiceProxyOptions is the query options to a Service's proxy call.
struct ServiceProxyOptions : public apis::meta::v1::TypeMeta {
	ServiceProxyOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceProxyOptions & other) const;
	MARSHAL_JSON;
// Path is the part of URLs that include service endpoints, suffixes,
// and parameters to use for the current proxy request to service.
// For example, the whole request URL is
// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
// Path is _search?q=user:kimchy.
// +optional
	string path; // `json:"path,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// NodeProxyOptions is the query options to a Node's proxy call.
struct NodeProxyOptions : public apis::meta::v1::TypeMeta {
	NodeProxyOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeProxyOptions & other) const;
	MARSHAL_JSON;
// Path is the URL path to use for the current proxy request to node.
// +optional
	string path; // `json:"path,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodProxyOptions is the query options to a Pod's proxy call.
struct PodProxyOptions : public apis::meta::v1::TypeMeta {
	PodProxyOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodProxyOptions & other) const;
	MARSHAL_JSON;
// Path is the URL path to use for the current proxy request to pod.
// +optional
	string path; // `json:"path,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodPortForwardOptions is the query options to a Pod's port forward call
// when using WebSockets.
// The `port` query parameter must specify the port or
// ports (comma separated) to forward over.
// Port forwarding over SPDY does not use these options. It requires the port
// to be passed in the `port` header as part of request.
struct PodPortForwardOptions : public apis::meta::v1::TypeMeta {
	PodPortForwardOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodPortForwardOptions & other) const;
	MARSHAL_JSON;
// List of ports to forward
// Required when using WebSockets
// +optional
	vector< long long > ports; // `json:"ports,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodExecOptions is the query options to a Pod's remote exec call.
// ---
// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
struct PodExecOptions : public apis::meta::v1::TypeMeta {
	PodExecOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodExecOptions & other) const;
	MARSHAL_JSON;
// Redirect the standard input stream of the pod for this call.
// Defaults to false.
// +optional
	bool Stdin; // `json:"stdin,omitempty"`
// Redirect the standard output stream of the pod for this call.
// Defaults to true.
// +optional
	bool Stdout; // `json:"stdout,omitempty"`
// Redirect the standard error stream of the pod for this call.
// Defaults to true.
// +optional
	bool Stderr; // `json:"stderr,omitempty"`
// TTY if true indicates that a tty will be allocated for the exec call.
// Defaults to false.
// +optional
	bool tty; // `json:"tty,omitempty"`
// Container in which to execute the command.
// Defaults to only container if there is only one container in the pod.
// +optional
	string container; // `json:"container,omitempty"`
// Command is the remote command to execute. argv array. Not executed within a shell.
	vector< string > command; // `json:"command"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodAttachOptions is the query options to a Pod's remote attach call.
// ---
// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
struct PodAttachOptions : public apis::meta::v1::TypeMeta {
	PodAttachOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodAttachOptions & other) const;
	MARSHAL_JSON;
// Stdin if true, redirects the standard input stream of the pod for this call.
// Defaults to false.
// +optional
	bool Stdin; // `json:"stdin,omitempty"`
// Stdout if true indicates that stdout is to be redirected for the attach call.
// Defaults to true.
// +optional
	bool Stdout; // `json:"stdout,omitempty"`
// Stderr if true indicates that stderr is to be redirected for the attach call.
// Defaults to true.
// +optional
	bool Stderr; // `json:"stderr,omitempty"`
// TTY if true indicates that a tty will be allocated for the attach call.
// This is passed through the container runtime so the tty
// is allocated on the worker node by the container runtime.
// Defaults to false.
// +optional
	bool tty; // `json:"tty,omitempty"`
// The container in which to execute the command.
// Defaults to only container if there is only one container in the pod.
// +optional
	string container; // `json:"container,omitempty"`
};
// +k8s:conversion-gen:explicit-from=net/url.Values
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodLogOptions is the query options for a Pod's logs REST call.
struct PodLogOptions : public apis::meta::v1::TypeMeta {
	PodLogOptions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodLogOptions & other) const;
	MARSHAL_JSON;
// The container for which to stream logs. Defaults to only container if there is one container in the pod.
// +optional
	string container; // `json:"container,omitempty"`
// Follow the log stream of the pod. Defaults to false.
// +optional
	bool follow; // `json:"follow,omitempty"`
// Return previous terminated container logs. Defaults to false.
// +optional
	bool previous; // `json:"previous,omitempty"`
// A relative time in seconds before the current time from which to show logs. If this value
// precedes the time a pod was started, only logs since the pod start will be returned.
// If this value is in the future, no logs will be returned.
// Only one of sinceSeconds or sinceTime may be specified.
// +optional
	shared_ptr< long long > sinceSeconds; // `json:"sinceSeconds,omitempty"`
// An RFC3339 timestamp from which to show logs. If this value
// precedes the time a pod was started, only logs since the pod start will be returned.
// If this value is in the future, no logs will be returned.
// Only one of sinceSeconds or sinceTime may be specified.
// +optional
	shared_ptr< goraw::Time > sinceTime; // `json:"sinceTime,omitempty"`
// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
// of log output. Defaults to false.
// +optional
	bool timestamps; // `json:"timestamps,omitempty"`
// If set, the number of lines from the end of the logs to show. If not specified,
// logs are shown from the creation of the container or sinceSeconds or sinceTime
// +optional
	shared_ptr< long long > tailLines; // `json:"tailLines,omitempty"`
// If set, the number of bytes to read from the server before terminating the
// log output. This may not display a complete final line of logging, and may return
// slightly more or slightly less than the specified limit.
// +optional
	shared_ptr< long long > limitBytes; // `json:"limitBytes,omitempty"`
// insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
// serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
// and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
// kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
// connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
// the actual log data coming from the real kubelet).
// +optional
	bool insecureSkipTLSVerifyBackend; // `json:"insecureSkipTLSVerifyBackend,omitempty"`
};
// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
// +k8s:openapi-gen=false
struct Preconditions {
	Preconditions();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Preconditions & other) const;
	MARSHAL_JSON;
	MARSHAL_MAP;
// Specifies the target UID.
// +optional
	shared_ptr< apis::goraw::UID > uid; // `json:"uid,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
// Deprecated in 1.7, please use the bindings subresource of pods instead.
struct Binding : public apis::meta::v1::TypeMeta {
	Binding();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Binding & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// The target object that you want to bind to the standard object.
	ObjectReference target; // `json:"target"`
};
// NamespaceCondition contains details about state of namespace.
struct NamespaceCondition {
	NamespaceCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NamespaceCondition & other) const;
	MARSHAL_JSON;
// Type of namespace controller condition.
	NamespaceConditionType type; // `json:"type"`
// Status of the condition, one of True, False, Unknown.
	ConditionStatus status; // `json:"status"`
// +optional
	goraw::Time lastTransitionTime; // `json:"lastTransitionTime,omitempty"`
// +optional
	string reason; // `json:"reason,omitempty"`
// +optional
	string message; // `json:"message,omitempty"`
};
// NamespaceStatus is information about the current status of a Namespace.
struct NamespaceStatus {
	NamespaceStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NamespaceStatus & other) const;
	MARSHAL_JSON;
// Phase is the current lifecycle phase of the namespace.
// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
// +optional
	NamespacePhase phase; // `json:"phase,omitempty"`
// Represents the latest available observations of a namespace's current state.
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< NamespaceCondition > conditions; // `json:"conditions,omitempty"`
};
// NamespaceSpec describes the attributes on a Namespace.
struct NamespaceSpec {
	NamespaceSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NamespaceSpec & other) const;
	MARSHAL_JSON;
// Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
// +optional
	vector< FinalizerName > finalizers; // `json:"finalizers,omitempty"`
};
// +genclient
// +genclient:nonNamespaced
// +genclient:skipVerbs=deleteCollection
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Namespace provides a scope for Names.
// Use of multiple namespaces is optional.
struct Namespace : public apis::meta::v1::TypeMeta {
	Namespace();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Namespace & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the behavior of the Namespace.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	NamespaceSpec spec; // `json:"spec,omitempty"`
// Status describes the current status of a Namespace.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	NamespaceStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// NamespaceList is a list of Namespaces.
struct NamespaceList : public apis::meta::v1::TypeMeta, public vector< Namespace > {
	NamespaceList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NamespaceList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// Items is the list of Namespace objects in the list.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	vector< Namespace > * items; // `json:"items"`
};
// NodeAddress contains information for the node's address.
struct NodeAddress {
	NodeAddress();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeAddress & other) const;
	MARSHAL_JSON;
// Node address type, one of Hostname, ExternalIP or InternalIP.
	NodeAddressType type; // `json:"type"`
// The node address.
	string address; // `json:"address"`
};
// NodeCondition contains condition information for a node.
struct NodeCondition {
	NodeCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeCondition & other) const;
	MARSHAL_JSON;
// Type of node condition.
	NodeConditionType type; // `json:"type"`
// Status of the condition, one of True, False, Unknown.
	ConditionStatus status; // `json:"status"`
// Last time we got an update on a given condition.
// +optional
	goraw::Time lastHeartbeatTime; // `json:"lastHeartbeatTime,omitempty"`
// Last time the condition transit from one status to another.
// +optional
	goraw::Time lastTransitionTime; // `json:"lastTransitionTime,omitempty"`
// (brief) reason for the condition's last transition.
// +optional
	string reason; // `json:"reason,omitempty"`
// Human readable message indicating details about last transition.
// +optional
	string message; // `json:"message,omitempty"`
};
// Describe a container image
struct ContainerImage {
	ContainerImage();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerImage & other) const;
	MARSHAL_JSON;
// Names by which this image is known.
// e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
	vector< string > names; // `json:"names"`
// The size of the image in bytes.
// +optional
	long long sizeBytes; // `json:"sizeBytes,omitempty"`
};
// Describes the class of pods that should avoid this node.
// Exactly one field should be set.
struct PodSignature {
	PodSignature();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodSignature & other) const;
	MARSHAL_JSON;
// Reference to controller whose pods should avoid this node.
// +optional
	shared_ptr< apis::meta::v1::OwnerReference > podController; // `json:"podController,omitempty"`
};
// Describes a class of pods that should avoid this node.
struct PreferAvoidPodsEntry {
	PreferAvoidPodsEntry();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PreferAvoidPodsEntry & other) const;
	MARSHAL_JSON;
// The class of pods.
	PodSignature podSignature; // `json:"podSignature"`
// Time at which this entry was added to the list.
// +optional
	goraw::Time evictionTime; // `json:"evictionTime,omitempty"`
// (brief) reason why this entry was added to the list.
// +optional
	string reason; // `json:"reason,omitempty"`
// Human readable message indicating why this entry was added to the list.
// +optional
	string message; // `json:"message,omitempty"`
};
// AvoidPods describes pods that should avoid this node. This is the value for a
// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
// will eventually become a field of NodeStatus.
struct AvoidPods {
	AvoidPods();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AvoidPods & other) const;
	MARSHAL_JSON;
// Bounded-sized list of signatures of pods that should avoid this node, sorted
// in timestamp order from oldest to newest. Size of the slice is unspecified.
// +optional
	vector< PreferAvoidPodsEntry > preferAvoidPods; // `json:"preferAvoidPods,omitempty"`
};
// AttachedVolume describes a volume attached to a node
struct AttachedVolume {
	AttachedVolume();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AttachedVolume & other) const;
	MARSHAL_JSON;
// Name of the attached volume
	UniqueVolumeName name; // `json:"name"`
// DevicePath represents the device path where the volume should be available
	string devicePath; // `json:"devicePath"`
};
// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
struct NodeSystemInfo {
	NodeSystemInfo();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeSystemInfo & other) const;
	MARSHAL_JSON;
// MachineID reported by the node. For unique machine identification
// in the cluster this field is preferred. Learn more from man(5)
// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
	string machineID; // `json:"machineID"`
// SystemUUID reported by the node. For unique machine identification
// MachineID is preferred. This field is specific to Red Hat hosts
// https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
	string systemUUID; // `json:"systemUUID"`
// Boot ID reported by the node.
	string bootID; // `json:"bootID"`
// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
	string kernelVersion; // `json:"kernelVersion"`
// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
	string osImage; // `json:"osImage"`
// ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
	string containerRuntimeVersion; // `json:"containerRuntimeVersion"`
// Kubelet Version reported by the node.
	string kubeletVersion; // `json:"kubeletVersion"`
// KubeProxy Version reported by the node.
	string kubeProxyVersion; // `json:"kubeProxyVersion"`
// The Operating System reported by the node
	string operatingSystem; // `json:"operatingSystem"`
// The Architecture reported by the node
	string architecture; // `json:"architecture"`
};
// DaemonEndpoint contains information about a single Daemon endpoint.
struct DaemonEndpoint {
	DaemonEndpoint();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const DaemonEndpoint & other) const;
	MARSHAL_JSON;
// Port number of the given endpoint.
	long long Port; // `json:"Port"`
};
// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
struct NodeDaemonEndpoints {
	NodeDaemonEndpoints();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeDaemonEndpoints & other) const;
	MARSHAL_JSON;
// Endpoint on which Kubelet is listening.
// +optional
	DaemonEndpoint kubeletEndpoint; // `json:"kubeletEndpoint,omitempty"`
};
// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
struct ConfigMapNodeConfigSource {
	ConfigMapNodeConfigSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapNodeConfigSource & other) const;
	MARSHAL_JSON;
// Namespace is the metadata.namespace of the referenced ConfigMap.
// This field is required in all cases.
	string ns; // `json:"namespace"`
// Name is the metadata.name of the referenced ConfigMap.
// This field is required in all cases.
	string name; // `json:"name"`
// UID is the metadata.UID of the referenced ConfigMap.
// This field is forbidden in Node.Spec, and required in Node.Status.
// +optional
	apis::goraw::UID uid; // `json:"uid,omitempty"`
// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
// This field is forbidden in Node.Spec, and required in Node.Status.
// +optional
	string resourceVersion; // `json:"resourceVersion,omitempty"`
// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
// This field is required in all cases.
	string kubeletConfigKey; // `json:"kubeletConfigKey"`
};
// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
struct NodeConfigSource {
	NodeConfigSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeConfigSource & other) const;
	MARSHAL_JSON;
// For historical context, regarding the below kind, apiVersion, and configMapRef deprecation tags:
// 1. kind/apiVersion were used by the kubelet to persist this struct to disk (they had no protobuf tags)
// 2. configMapRef and proto tag 1 were used by the API to refer to a configmap,
// but used a generic ObjectReference type that didn't really have the fields we needed
// All uses/persistence of the NodeConfigSource struct prior to 1.11 were gated by alpha feature flags,
// so there was no persisted data for these fields that needed to be migrated/handled.
// +k8s:deprecated=kind
// +k8s:deprecated=apiVersion
// +k8s:deprecated=configMapRef,protobuf=1
// ConfigMap is a reference to a Node's ConfigMap
	shared_ptr< ConfigMapNodeConfigSource > configMap; // `json:"configMap,omitempty"`
};
// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
struct NodeConfigStatus {
	NodeConfigStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeConfigStatus & other) const;
	MARSHAL_JSON;
// Assigned reports the checkpointed config the node will try to use.
// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
// config payload to local disk, along with a record indicating intended
// config. The node refers to this record to choose its config checkpoint, and
// reports this record in Assigned. Assigned only updates in the status after
// the record has been checkpointed to disk. When the Kubelet is restarted,
// it tries to make the Assigned config the Active config by loading and
// validating the checkpointed payload identified by Assigned.
// +optional
	shared_ptr< NodeConfigSource > assigned; // `json:"assigned,omitempty"`
// Active reports the checkpointed config the node is actively using.
// Active will represent either the current version of the Assigned config,
// or the current LastKnownGood config, depending on whether attempting to use the
// Assigned config results in an error.
// +optional
	shared_ptr< NodeConfigSource > active; // `json:"active,omitempty"`
// LastKnownGood reports the checkpointed config the node will fall back to
// when it encounters an error attempting to use the Assigned config.
// The Assigned config becomes the LastKnownGood config when the node determines
// that the Assigned config is stable and correct.
// This is currently implemented as a 10-minute soak period starting when the local
// record of Assigned config is updated. If the Assigned config is Active at the end
// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
// because the local default config is always assumed good.
// You should not make assumptions about the node's method of determining config stability
// and correctness, as this may change or become configurable in the future.
// +optional
	shared_ptr< NodeConfigSource > lastKnownGood; // `json:"lastKnownGood,omitempty"`
// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
// to load or validate the Assigned config, etc.
// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
// by fixing the config assigned in Spec.ConfigSource.
// You can find additional information for debugging by searching the error message in the Kubelet log.
// Error is a human-readable description of the error state; machines can check whether or not Error
// is empty, but should not rely on the stability of the Error text across Kubelet versions.
// +optional
	string error; // `json:"error,omitempty"`
};
// NodeStatus is information about the current status of a node.
struct NodeStatus {
	NodeStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeStatus & other) const;
	MARSHAL_JSON;
// Capacity represents the total resources of a node.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
// +optional
	ResourceList capacity; // `json:"capacity,omitempty"`
// Allocatable represents the resources of a node that are available for scheduling.
// Defaults to Capacity.
// +optional
	ResourceList allocatable; // `json:"allocatable,omitempty"`
// NodePhase is the recently observed lifecycle phase of the node.
// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
// The field is never populated, and now is deprecated.
// +optional
	NodePhase phase; // `json:"phase,omitempty"`
// Conditions is an array of current observed node conditions.
// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< NodeCondition > conditions; // `json:"conditions,omitempty"`
// List of addresses reachable to the node.
// Queried from cloud provider, if available.
// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
// Note: This field is declared as mergeable, but the merge key is not sufficiently
// unique, which can cause data corruption when it is merged. Callers should instead
// use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< NodeAddress > addresses; // `json:"addresses,omitempty"`
// Endpoints of daemons running on the Node.
// +optional
	NodeDaemonEndpoints daemonEndpoints; // `json:"daemonEndpoints,omitempty"`
// Set of ids/uuids to uniquely identify the node.
// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
// +optional
	NodeSystemInfo nodeInfo; // `json:"nodeInfo,omitempty"`
// List of container images on this node
// +optional
	vector< ContainerImage > images; // `json:"images,omitempty"`
// List of attachable volumes in use (mounted) by the node.
// +optional
	vector< UniqueVolumeName > volumesInUse; // `json:"volumesInUse,omitempty"`
// List of volumes that are attached to the node.
// +optional
	vector< AttachedVolume > volumesAttached; // `json:"volumesAttached,omitempty"`
// Status of the config assigned to the node via the dynamic Kubelet config feature.
// +optional
	shared_ptr< NodeConfigStatus > config; // `json:"config,omitempty"`
};
// EndpointPort is a tuple that describes a single port.
struct EndpointPort {
	EndpointPort();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EndpointPort & other) const;
	MARSHAL_JSON;
// The name of this port.  This must match the 'name' field in the
// corresponding ServicePort.
// Must be a DNS_LABEL.
// Optional only if one port is defined.
// +optional
	string name; // `json:"name,omitempty"`
// The port number of the endpoint.
	long long port; // `json:"port"`
// The IP protocol for this port.
// Must be UDP, TCP, or SCTP.
// Default is TCP.
// +optional
	Protocol protocol; // `json:"protocol,omitempty"`
// The application protocol for this port.
// This field follows standard Kubernetes label syntax.
// Un-prefixed names are reserved for IANA standard service names (as per
// RFC-6335 and http://www.iana.org/assignments/service-names).
// Non-standard protocols should use prefixed names such as
// mycompany.com/my-custom-protocol.
// This is a beta field that is guarded by the ServiceAppProtocol feature
// gate and enabled by default.
// +optional
	shared_ptr< string > appProtocol; // `json:"appProtocol,omitempty"`
};
// EndpointAddress is a tuple that describes single IP address.
struct EndpointAddress {
	EndpointAddress();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EndpointAddress & other) const;
	MARSHAL_JSON;
// The IP of this endpoint.
// May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
// or link-local multicast ((224.0.0.0/24).
// IPv6 is also accepted but not fully supported on all platforms. Also, certain
// kubernetes components, like kube-proxy, are not IPv6 ready.
// TODO: This should allow hostname or IP, See #4447.
	string ip; // `json:"ip"`
// The Hostname of this endpoint
// +optional
	string hostname; // `json:"hostname,omitempty"`
// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
// +optional
	shared_ptr< string > nodeName; // `json:"nodeName,omitempty"`
// Reference to object providing the endpoint.
// +optional
	shared_ptr< ObjectReference > targetRef; // `json:"targetRef,omitempty"`
};
// EndpointSubset is a group of addresses with a common set of ports. The
// expanded set of endpoints is the Cartesian product of Addresses x Ports.
// For example, given:
// {
// Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
// Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
// }
// The resulting set of endpoints can be viewed as:
// a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
// b: [ 10.10.1.1:309, 10.10.2.2:309 ]
struct EndpointSubset {
	EndpointSubset();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EndpointSubset & other) const;
	MARSHAL_JSON;
// IP addresses which offer the related ports that are marked as ready. These endpoints
// should be considered safe for load balancers and clients to utilize.
// +optional
	vector< EndpointAddress > addresses; // `json:"addresses,omitempty"`
// IP addresses which offer the related ports but are not currently marked as ready
// because they have not yet finished starting, have recently failed a readiness check,
// or have recently failed a liveness check.
// +optional
	vector< EndpointAddress > notReadyAddresses; // `json:"notReadyAddresses,omitempty"`
// Port numbers available on the related IP addresses.
// +optional
	vector< EndpointPort > ports; // `json:"ports,omitempty"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Endpoints is a collection of endpoints that implement the actual service. Example:
// Name: "mysvc",
// Subsets: [
// {
// Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
// Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
// },
// {
// Addresses: [{"ip": "10.10.3.3"}],
// Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
// },
// ]
struct Endpoints : public apis::meta::v1::TypeMeta {
	Endpoints();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Endpoints & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// The set of all endpoints is the union of all subsets. Addresses are placed into
// subsets according to the IPs they share. A single address with multiple ports,
// some of which are ready and some of which are not (because they come from
// different containers) will result in the address being displayed in different
// subsets for the different ports. No address will appear in both Addresses and
// NotReadyAddresses in the same subset.
// Sets of addresses and ports that comprise a service.
// +optional
	vector< EndpointSubset > subsets; // `json:"subsets,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// EndpointsList is a list of endpoints.
struct EndpointsList : public apis::meta::v1::TypeMeta, public vector< Endpoints > {
	EndpointsList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EndpointsList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of endpoints.
	vector< Endpoints > * items; // `json:"items"`
};
// +genclient
// +genclient:method=CreateToken,verb=create,subresource=token,input=k8s.io/api/authentication/v1.TokenRequest,result=k8s.io/api/authentication/v1.TokenRequest
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ServiceAccount binds together:
// * a name, understood by users, and perhaps by peripheral systems, for an identity
// * a principal that can be authenticated and authorized
// * a set of secrets
struct ServiceAccount : public apis::meta::v1::TypeMeta {
	ServiceAccount();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceAccount & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount.
// More info: https://kubernetes.io/docs/concepts/configuration/secret
// +optional
// +patchMergeKey=name
// +patchStrategy=merge
	vector< ObjectReference > secrets; // `json:"secrets,omitempty"`
// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
// +optional
	vector< LocalObjectReference > imagePullSecrets; // `json:"imagePullSecrets,omitempty"`
// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
// Can be overridden at the pod level.
// +optional
	shared_ptr< bool > automountServiceAccountToken; // `json:"automountServiceAccountToken,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ServiceAccountList is a list of ServiceAccount objects
struct ServiceAccountList : public apis::meta::v1::TypeMeta, public vector< ServiceAccount > {
	ServiceAccountList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceAccountList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of ServiceAccounts.
// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	vector< ServiceAccount > * items; // `json:"items"`
};
// ServicePort contains information on service's port.
struct ServicePort {
	ServicePort();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServicePort & other) const;
	MARSHAL_JSON;
// The name of this port within the service. This must be a DNS_LABEL.
// All ports within a ServiceSpec must have unique names. When considering
// the endpoints for a Service, this must match the 'name' field in the
// EndpointPort.
// Optional if only one ServicePort is defined on this service.
// +optional
	string name; // `json:"name,omitempty"`
// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
// Default is TCP.
// +optional
	Protocol protocol; // `json:"protocol,omitempty"`
// The application protocol for this port.
// This field follows standard Kubernetes label syntax.
// Un-prefixed names are reserved for IANA standard service names (as per
// RFC-6335 and http://www.iana.org/assignments/service-names).
// Non-standard protocols should use prefixed names such as
// mycompany.com/my-custom-protocol.
// This is a beta field that is guarded by the ServiceAppProtocol feature
// gate and enabled by default.
// +optional
	shared_ptr< string > appProtocol; // `json:"appProtocol,omitempty"`
// The port that will be exposed by this service.
	long long port; // `json:"port"`
// Number or name of the port to access on the pods targeted by the service.
// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
// If this is a string, it will be looked up as a named port in the
// target Pod's container ports. If this is not specified, the value
// of the 'port' field is used (an identity map).
// This field is ignored for services with clusterIP=None, and should be
// omitted or set equal to the 'port' field.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
// +optional
	apis::goraw::IntOrString targetPort; // `json:"targetPort,omitempty"`
// The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
// Usually assigned by the system. If specified, it will be allocated to the service
// if unused or else creation of the service will fail.
// Default is to auto-allocate a port if the ServiceType of this Service requires one.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
// +optional
	long long nodePort; // `json:"nodePort,omitempty"`
};
// LoadBalancerIngress represents the status of a load-balancer ingress point:
// traffic intended for the service should be sent to an ingress point.
struct LoadBalancerIngress {
	LoadBalancerIngress();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LoadBalancerIngress & other) const;
	MARSHAL_JSON;
// IP is set for load-balancer ingress points that are IP based
// (typically GCE or OpenStack load-balancers)
// +optional
	string ip; // `json:"ip,omitempty"`
// Hostname is set for load-balancer ingress points that are DNS based
// (typically AWS load-balancers)
// +optional
	string hostname; // `json:"hostname,omitempty"`
};
// LoadBalancerStatus represents the status of a load-balancer.
struct LoadBalancerStatus {
	LoadBalancerStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LoadBalancerStatus & other) const;
	MARSHAL_JSON;
// Ingress is a list containing ingress points for the load-balancer.
// Traffic intended for the service should be sent to these ingress points.
// +optional
	vector< LoadBalancerIngress > ingress; // `json:"ingress"`
};
// ServiceStatus represents the current status of a service.
struct ServiceStatus {
	ServiceStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceStatus & other) const;
	MARSHAL_JSON;
// LoadBalancer contains the current status of the load-balancer,
// if one is present.
// +optional
	LoadBalancerStatus loadBalancer; // `json:"loadBalancer"`
};
// ClientIPConfig represents the configurations of Client IP based session affinity.
struct ClientIPConfig {
	ClientIPConfig();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ClientIPConfig & other) const;
	MARSHAL_JSON;
// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
// Default value is 10800(for 3 hours).
// +optional
	shared_ptr< long long > timeoutSeconds; // `json:"timeoutSeconds,omitempty"`
};
// SessionAffinityConfig represents the configurations of session affinity.
struct SessionAffinityConfig {
	SessionAffinityConfig();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SessionAffinityConfig & other) const;
	MARSHAL_JSON;
// clientIP contains the configurations of Client IP based session affinity.
// +optional
	shared_ptr< ClientIPConfig > clientIP; // `json:"clientIP,omitempty"`
};
// ServiceSpec describes the attributes that a user creates on a service.
struct ServiceSpec {
	ServiceSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceSpec & other) const;
	MARSHAL_JSON;
// The list of ports that are exposed by this service.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
// +patchMergeKey=port
// +patchStrategy=merge
// +listType=map
// +listMapKey=port
// +listMapKey=protocol
	vector< ServicePort > ports; // `json:"ports,omitempty"`
// Route service traffic to pods with label keys and values matching this
// selector. If empty or not present, the service is assumed to have an
// external process managing its endpoints, which Kubernetes will not
// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
// Ignored if type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/
// +optional
	map< string , string > selector; // `json:"selector,omitempty"`
// clusterIP is the IP address of the service and is usually assigned
// randomly by the master. If an address is specified manually and is not in
// use by others, it will be allocated to the service; otherwise, creation
// of the service will fail. This field can not be changed through updates.
// Valid values are "None", empty string (""), or a valid IP address. "None"
// can be specified for headless services when proxying is not required.
// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
// type is ExternalName.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
// +optional
	string clusterIP; // `json:"clusterIP,omitempty"`
// type determines how the Service is exposed. Defaults to ClusterIP. Valid
// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
// "ExternalName" maps to the specified externalName.
// "ClusterIP" allocates a cluster-internal IP address for load-balancing to
// endpoints. Endpoints are determined by the selector or if that is not
// specified, by manual construction of an Endpoints object. If clusterIP is
// "None", no virtual IP is allocated and the endpoints are published as a
// set of endpoints rather than a stable IP.
// "NodePort" builds on ClusterIP and allocates a port on every node which
// routes to the clusterIP.
// "LoadBalancer" builds on NodePort and creates an
// external load-balancer (if supported in the current cloud) which routes
// to the clusterIP.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
// +optional
	ServiceType type; // `json:"type,omitempty"`
// externalIPs is a list of IP addresses for which nodes in the cluster
// will also accept traffic for this service.  These IPs are not managed by
// Kubernetes.  The user is responsible for ensuring that traffic arrives
// at a node with this IP.  A common example is external load-balancers
// that are not part of the Kubernetes system.
// +optional
	vector< string > externalIPs; // `json:"externalIPs,omitempty"`
// Supports "ClientIP" and "None". Used to maintain session affinity.
// Enable client IP based session affinity.
// Must be ClientIP or None.
// Defaults to None.
// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
// +optional
	ServiceAffinity sessionAffinity; // `json:"sessionAffinity,omitempty"`
// Only applies to Service Type: LoadBalancer
// LoadBalancer will get created with the IP specified in this field.
// This feature depends on whether the underlying cloud-provider supports specifying
// the loadBalancerIP when a load balancer is created.
// This field will be ignored if the cloud-provider does not support the feature.
// +optional
	string loadBalancerIP; // `json:"loadBalancerIP,omitempty"`
// If specified and supported by the platform, this will restrict traffic through the cloud-provider
// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
// cloud-provider does not support the feature."
// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
// +optional
	vector< string > loadBalancerSourceRanges; // `json:"loadBalancerSourceRanges,omitempty"`
// externalName is the external reference that kubedns or equivalent will
// return as a CNAME record for this service. No proxying will be involved.
// Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
// and requires Type to be ExternalName.
// +optional
	string externalName; // `json:"externalName,omitempty"`
// externalTrafficPolicy denotes if this Service desires to route external
// traffic to node-local or cluster-wide endpoints. "Local" preserves the
// client source IP and avoids a second hop for LoadBalancer and Nodeport
// type services, but risks potentially imbalanced traffic spreading.
// "Cluster" obscures the client source IP and may cause a second hop to
// another node, but should have good overall load-spreading.
// +optional
	ServiceExternalTrafficPolicyType externalTrafficPolicy; // `json:"externalTrafficPolicy,omitempty"`
// healthCheckNodePort specifies the healthcheck nodePort for the service.
// If not specified, HealthCheckNodePort is created by the service api
// backend with the allocated nodePort. Will use user-specified nodePort value
// if specified by the client. Only effects when Type is set to LoadBalancer
// and ExternalTrafficPolicy is set to Local.
// +optional
	long long healthCheckNodePort; // `json:"healthCheckNodePort,omitempty"`
// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
// Service should disregard any indications of ready/not-ready.
// The primary use case for setting this field is for a StatefulSet's Headless Service to
// propagate SRV DNS records for its Pods for the purpose of peer discovery.
// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
// Services interpret this to mean that all endpoints are considered "ready" even if the
// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
// through the Endpoints or EndpointSlice resources can safely assume this behavior.
// +optional
	bool publishNotReadyAddresses; // `json:"publishNotReadyAddresses,omitempty"`
// sessionAffinityConfig contains the configurations of session affinity.
// +optional
	shared_ptr< SessionAffinityConfig > sessionAffinityConfig; // `json:"sessionAffinityConfig,omitempty"`
// ipFamily specifies whether this Service has a preference for a particular IP family (e.g.
// IPv4 vs. IPv6) when the IPv6DualStack feature gate is enabled. In a dual-stack cluster,
// you can specify ipFamily when creating a ClusterIP Service to determine whether the
// controller will allocate an IPv4 or IPv6 IP for it, and you can specify ipFamily when
// creating a headless Service to determine whether it will have IPv4 or IPv6 Endpoints. In
// either case, if you do not specify an ipFamily explicitly, it will default to the
// cluster's primary IP family.
// This field is part of an alpha feature, and you should not make any assumptions about its
// semantics other than those described above. In particular, you should not assume that it
// can (or cannot) be changed after creation time; that it can only have the values "IPv4"
// and "IPv6"; or that its current value on a given Service correctly reflects the current
// state of that Service. (For ClusterIP Services, look at clusterIP to see if the Service
// is IPv4 or IPv6. For headless Services, look at the endpoints, which may be dual-stack in
// the future. For ExternalName Services, ipFamily has no meaning, but it may be set to an
// irrelevant value anyway.)
// +optional
	shared_ptr< IPFamily > ipFamily; // `json:"ipFamily,omitempty"`
// topologyKeys is a preference-order list of topology keys which
// implementations of services should use to preferentially sort endpoints
// when accessing this Service, it can not be used at the same time as
// externalTrafficPolicy=Local.
// Topology keys must be valid label keys and at most 16 keys may be specified.
// Endpoints are chosen based on the first topology key with available backends.
// If this field is specified and all entries have no backends that match
// the topology of the client, the service has no backends for that client
// and connections should fail.
// The special value "*" may be used to mean "any topology". This catch-all
// value, if used, only makes sense as the last value in the list.
// If this is not specified or empty, no topology constraints will be applied.
// +optional
	vector< string > topologyKeys; // `json:"topologyKeys,omitempty"`
};
// +genclient
// +genclient:skipVerbs=deleteCollection
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Service is a named abstraction of software service (for example, mysql) consisting of local port
// (for example 3306) that the proxy listens on, and the selector that determines which pods
// will answer requests sent through the proxy.
struct Service : public apis::meta::v1::TypeMeta {
	Service();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Service & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the behavior of a service.
// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ServiceSpec spec; // `json:"spec,omitempty"`
// Most recently observed status of the service.
// Populated by the system.
// Read-only.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ServiceStatus status; // `json:"status"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ServiceList holds a list of services.
struct ServiceList : public apis::meta::v1::TypeMeta, public vector< Service > {
	ServiceList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of services
	vector< Service > * items; // `json:"items"`
};
// ReplicationControllerCondition describes the state of a replication controller at a certain point.
struct ReplicationControllerCondition {
	ReplicationControllerCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ReplicationControllerCondition & other) const;
	MARSHAL_JSON;
// Type of replication controller condition.
	ReplicationControllerConditionType type; // `json:"type"`
// Status of the condition, one of True, False, Unknown.
	ConditionStatus status; // `json:"status"`
// The last time the condition transitioned from one status to another.
// +optional
	goraw::Time lastTransitionTime; // `json:"lastTransitionTime,omitempty"`
// The reason for the condition's last transition.
// +optional
	string reason; // `json:"reason,omitempty"`
// A human readable message indicating details about the transition.
// +optional
	string message; // `json:"message,omitempty"`
};
// ReplicationControllerStatus represents the current status of a replication
// controller.
struct ReplicationControllerStatus {
	ReplicationControllerStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ReplicationControllerStatus & other) const;
	MARSHAL_JSON;
// Replicas is the most recently oberved number of replicas.
// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
	long long replicas; // `json:"replicas"`
// The number of pods that have labels matching the labels of the pod template of the replication controller.
// +optional
	long long fullyLabeledReplicas; // `json:"fullyLabeledReplicas,omitempty"`
// The number of ready replicas for this replication controller.
// +optional
	long long readyReplicas; // `json:"readyReplicas,omitempty"`
// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
// +optional
	long long availableReplicas; // `json:"availableReplicas,omitempty"`
// ObservedGeneration reflects the generation of the most recently observed replication controller.
// +optional
	long long observedGeneration; // `json:"observedGeneration,omitempty"`
// Represents the latest available observations of a replication controller's current state.
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< ReplicationControllerCondition > conditions; // `json:"conditions,omitempty"`
};
// IP address information for entries in the (plural) PodIPs field.
// Each entry includes:
// IP: An IP address allocated to the pod. Routable at least within the cluster.
struct PodIP {
	PodIP();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodIP & other) const;
	MARSHAL_JSON;
// ip is an IP address (IPv4 or IPv6) assigned to the pod
	string ip; // `json:"ip,omitempty"`
};
// PodDNSConfigOption defines DNS resolver options of a pod.
struct PodDNSConfigOption {
	PodDNSConfigOption();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodDNSConfigOption & other) const;
	MARSHAL_JSON;
// Required.
	string name; // `json:"name,omitempty"`
// +optional
	shared_ptr< string > value; // `json:"value,omitempty"`
};
// PodDNSConfig defines the DNS parameters of a pod in addition to
// those generated from DNSPolicy.
struct PodDNSConfig {
	PodDNSConfig();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodDNSConfig & other) const;
	MARSHAL_JSON;
// A list of DNS name server IP addresses.
// This will be appended to the base nameservers generated from DNSPolicy.
// Duplicated nameservers will be removed.
// +optional
	vector< string > nameservers; // `json:"nameservers,omitempty"`
// A list of DNS search domains for host-name lookup.
// This will be appended to the base search paths generated from DNSPolicy.
// Duplicated search paths will be removed.
// +optional
	vector< string > searches; // `json:"searches,omitempty"`
// A list of DNS resolver options.
// This will be merged with the base options generated from DNSPolicy.
// Duplicated entries will be removed. Resolution options given in Options
// will override those that appear in the base DNSPolicy.
// +optional
	vector< PodDNSConfigOption > options; // `json:"options,omitempty"`
};
// SeccompProfile defines a pod/container's seccomp profile settings.
// Only one profile source may be set.
// +union
struct SeccompProfile {
	SeccompProfile();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SeccompProfile & other) const;
	MARSHAL_JSON;
// type indicates which kind of seccomp profile will be applied.
// Valid options are:
// 
// Localhost - a profile defined in a file on the node should be used.
// RuntimeDefault - the container runtime default profile should be used.
// Unconfined - no profile should be applied.
// +unionDiscriminator
	SeccompProfileType type; // `json:"type"`
// localhostProfile indicates a profile defined in a file on the node should be used.
// The profile must be preconfigured on the node to work.
// Must be a descending path, relative to the kubelet's configured seccomp profile location.
// Must only be set if type is "Localhost".
// +optional
	shared_ptr< string > localhostProfile; // `json:"localhostProfile,omitempty"`
};
// PodSecurityContext holds pod-level security attributes and common container settings.
// Some fields are also present in container.securityContext.  Field values of
// container.securityContext take precedence over field values of PodSecurityContext.
struct PodSecurityContext {
	PodSecurityContext();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodSecurityContext & other) const;
	MARSHAL_JSON;
// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// +optional
	shared_ptr< SELinuxOptions > seLinuxOptions; // `json:"seLinuxOptions,omitempty"`
// The Windows specific settings applied to all containers.
// If unspecified, the options within a container's SecurityContext will be used.
// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< WindowsSecurityContextOptions > windowsOptions; // `json:"windowsOptions,omitempty"`
// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// +optional
	shared_ptr< long long > runAsUser; // `json:"runAsUser,omitempty"`
// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// +optional
	shared_ptr< long long > runAsGroup; // `json:"runAsGroup,omitempty"`
// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< bool > runAsNonRoot; // `json:"runAsNonRoot,omitempty"`
// A list of groups applied to the first process run in each container, in addition
// to the container's primary GID.  If unspecified, no groups will be added to
// any container.
// +optional
	vector< long long > supplementalGroups; // `json:"supplementalGroups,omitempty"`
// A special supplemental group that applies to all containers in a pod.
// Some volume types allow the Kubelet to change the ownership of that volume
// to be owned by the pod:
// 
// 1. The owning GID will be the FSGroup
// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
// 3. The permission bits are OR'd with rw-rw----
// 
// If unset, the Kubelet will not modify the ownership and permissions of any volume.
// +optional
	shared_ptr< long long > fsGroup; // `json:"fsGroup,omitempty"`
// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
// sysctls (by the container runtime) might fail to launch.
// +optional
	vector< Sysctl > sysctls; // `json:"sysctls,omitempty"`
// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
// before being exposed inside Pod. This field will only apply to
// volume types which support fsGroup based ownership(and permissions).
// It will have no effect on ephemeral volume types such as: secret, configmaps
// and emptydir.
// Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
// +optional
	shared_ptr< PodFSGroupChangePolicy > fsGroupChangePolicy; // `json:"fsGroupChangePolicy,omitempty"`
// The seccomp options to use by the containers in this pod.
// +optional
	shared_ptr< SeccompProfile > seccompProfile; // `json:"seccompProfile,omitempty"`
};
// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
// pod's hosts file.
struct HostAlias {
	HostAlias();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const HostAlias & other) const;
	MARSHAL_JSON;
// IP address of the host file entry.
	string ip; // `json:"ip,omitempty"`
// Hostnames for the above IP address.
	vector< string > hostnames; // `json:"hostnames,omitempty"`
};
// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
struct TopologySpreadConstraint {
	TopologySpreadConstraint();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const TopologySpreadConstraint & other) const;
	MARSHAL_JSON;
// MaxSkew describes the degree to which pods may be unevenly distributed.
// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
// between the number of matching pods in the target topology and the global minimum.
// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
// labelSelector spread as 1/1/0:
// +-------+-------+-------+
// | zone1 | zone2 | zone3 |
// +-------+-------+-------+
// |   P   |   P   |       |
// +-------+-------+-------+
// - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
// violate MaxSkew(1).
// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
// to topologies that satisfy it.
// It's a required field. Default value is 1 and 0 is not allowed.
	long long maxSkew; // `json:"maxSkew"`
// TopologyKey is the key of node labels. Nodes that have a label with this key
// and identical values are considered to be in the same topology.
// We consider each <key, value> as a "bucket", and try to put balanced number
// of pods into each bucket.
// It's a required field.
	string topologyKey; // `json:"topologyKey"`
// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
// the spread constraint.
// - DoNotSchedule (default) tells the scheduler not to schedule it.
// - ScheduleAnyway tells the scheduler to schedule the pod in any location,
// but giving higher precedence to topologies that would help reduce the
// skew.
// A constraint is considered "Unsatisfiable" for an incoming pod
// if and only if every possible node assigment for that pod would violate
// "MaxSkew" on some topology.
// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
// labelSelector spread as 3/1/1:
// +-------+-------+-------+
// | zone1 | zone2 | zone3 |
// +-------+-------+-------+
// | P P P |   P   |   P   |
// +-------+-------+-------+
// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
// won't make it *more* imbalanced.
// It's a required field.
	UnsatisfiableConstraintAction whenUnsatisfiable; // `json:"whenUnsatisfiable"`
// LabelSelector is used to find matching pods.
// Pods that match this label selector are counted to determine the number of pods
// in their corresponding topology domain.
// +optional
	shared_ptr< apis::meta::v1::LabelSelector > labelSelector; // `json:"labelSelector,omitempty"`
};
// PodReadinessGate contains the reference to a pod condition
struct PodReadinessGate {
	PodReadinessGate();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodReadinessGate & other) const;
	MARSHAL_JSON;
// ConditionType refers to a condition in the pod's condition list with matching type.
	PodConditionType conditionType; // `json:"conditionType"`
};
// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
struct Toleration {
	Toleration();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Toleration & other) const;
	MARSHAL_JSON;
// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
// +optional
	string key; // `json:"key,omitempty"`
// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
// +optional
	TolerationOperator op; // `json:"operator,omitempty"`
// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
// +optional
	string value; // `json:"value,omitempty"`
// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
// +optional
	TaintEffect effect; // `json:"effect,omitempty"`
// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
// +optional
	shared_ptr< long long > tolerationSeconds; // `json:"tolerationSeconds,omitempty"`
};
// The node this Taint is attached to has the "effect" on
// any pod that does not tolerate the Taint.
struct Taint {
	Taint();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Taint & other) const;
	MARSHAL_JSON;
// Required. The taint key to be applied to a node.
	string key; // `json:"key"`
// The taint value corresponding to the taint key.
// +optional
	string value; // `json:"value,omitempty"`
// Required. The effect of the taint on pods
// that do not tolerate the taint.
// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	TaintEffect effect; // `json:"effect"`
// TimeAdded represents the time at which the taint was added.
// It is only written for NoExecute taints.
// +optional
	shared_ptr< goraw::Time > timeAdded; // `json:"timeAdded,omitempty"`
};
// NodeSpec describes the attributes that a node is created with.
struct NodeSpec {
	NodeSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeSpec & other) const;
	MARSHAL_JSON;
// PodCIDR represents the pod IP range assigned to the node.
// +optional
	string podCIDR; // `json:"podCIDR,omitempty"`
// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
// each of IPv4 and IPv6.
// +optional
// +patchStrategy=merge
	vector< string > podCIDRs; // `json:"podCIDRs,omitempty"`
// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
// +optional
	string providerID; // `json:"providerID,omitempty"`
// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
// +optional
	bool unschedulable; // `json:"unschedulable,omitempty"`
// If specified, the node's taints.
// +optional
	vector< Taint > taints; // `json:"taints,omitempty"`
// If specified, the source to get node configuration from
// The DynamicKubeletConfig feature gate must be enabled for the Kubelet to use this field
// +optional
	shared_ptr< NodeConfigSource > configSource; // `json:"configSource,omitempty"`
// Deprecated. Not all kubelets will set this field. Remove field after 1.13.
// see: https://issues.k8s.io/61966
// +optional
	string externalID; // `json:"externalID,omitempty"`
};
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Node is a worker node in Kubernetes.
// Each node will have a unique identifier in the cache (i.e. in etcd).
struct Node : public apis::meta::v1::TypeMeta {
	Node();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Node & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the behavior of a node.
// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	NodeSpec spec; // `json:"spec,omitempty"`
// Most recently observed status of the node.
// Populated by the system.
// Read-only.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	NodeStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// NodeList is the whole list of all Nodes which have been registered with master.
struct NodeList : public apis::meta::v1::TypeMeta, public vector< Node > {
	NodeList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of nodes
	vector< Node > * items; // `json:"items"`
};
// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
struct PodAffinityTerm {
	PodAffinityTerm();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodAffinityTerm & other) const;
	MARSHAL_JSON;
// A label query over a set of resources, in this case pods.
// +optional
	shared_ptr< apis::meta::v1::LabelSelector > labelSelector; // `json:"labelSelector,omitempty"`
// namespaces specifies which namespaces the labelSelector applies to (matches against);
// null or empty list means "this pod's namespace"
// +optional
	vector< string > namespaces; // `json:"namespaces,omitempty"`
// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
	string topologyKey; // `json:"topologyKey"`
};
// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
struct WeightedPodAffinityTerm {
	WeightedPodAffinityTerm();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const WeightedPodAffinityTerm & other) const;
	MARSHAL_JSON;
// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
	long long weight; // `json:"weight"`
// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm podAffinityTerm; // `json:"podAffinityTerm"`
};
// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
struct PodAntiAffinity {
	PodAntiAffinity();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodAntiAffinity & other) const;
	MARSHAL_JSON;
// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system will try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
// +optional
// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
// +optional
	vector< PodAffinityTerm > requiredDuringSchedulingIgnoredDuringExecution; // `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
// +optional
	vector< WeightedPodAffinityTerm > preferredDuringSchedulingIgnoredDuringExecution; // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
};
// Pod affinity is a group of inter pod affinity scheduling rules.
struct PodAffinity {
	PodAffinity();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodAffinity & other) const;
	MARSHAL_JSON;
// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system will try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
// +optional
// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
// +optional
	vector< PodAffinityTerm > requiredDuringSchedulingIgnoredDuringExecution; // `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
// +optional
	vector< WeightedPodAffinityTerm > preferredDuringSchedulingIgnoredDuringExecution; // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
};
// A topology selector requirement is a selector that matches given label.
// This is an alpha feature and may change in the future.
struct TopologySelectorLabelRequirement {
	TopologySelectorLabelRequirement();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const TopologySelectorLabelRequirement & other) const;
	MARSHAL_JSON;
// The label key that the selector applies to.
	string key; // `json:"key"`
// An array of string values. One value must match the label to be selected.
// Each entry in Values is ORed.
	vector< string > values; // `json:"values"`
};
// A topology selector term represents the result of label queries.
// A null or empty topology selector term matches no objects.
// The requirements of them are ANDed.
// It provides a subset of functionality as NodeSelectorTerm.
// This is an alpha feature and may change in the future.
struct TopologySelectorTerm {
	TopologySelectorTerm();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const TopologySelectorTerm & other) const;
	MARSHAL_JSON;
// A list of topology selector requirements by labels.
// +optional
	vector< TopologySelectorLabelRequirement > matchLabelExpressions; // `json:"matchLabelExpressions,omitempty"`
};
// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
struct NodeSelectorRequirement {
	NodeSelectorRequirement();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeSelectorRequirement & other) const;
	MARSHAL_JSON;
// The label key that the selector applies to.
	string key; // `json:"key"`
// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	NodeSelectorOperator op; // `json:"operator"`
// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
// +optional
	vector< string > values; // `json:"values,omitempty"`
};
// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
struct NodeSelectorTerm {
	NodeSelectorTerm();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeSelectorTerm & other) const;
	MARSHAL_JSON;
// A list of node selector requirements by node's labels.
// +optional
	vector< NodeSelectorRequirement > matchExpressions; // `json:"matchExpressions,omitempty"`
// A list of node selector requirements by node's fields.
// +optional
	vector< NodeSelectorRequirement > matchFields; // `json:"matchFields,omitempty"`
};
// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
struct PreferredSchedulingTerm {
	PreferredSchedulingTerm();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PreferredSchedulingTerm & other) const;
	MARSHAL_JSON;
// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	long long weight; // `json:"weight"`
// A node selector term, associated with the corresponding weight.
	NodeSelectorTerm preference; // `json:"preference"`
};
// A node selector represents the union of the results of one or more label queries
// over a set of nodes; that is, it represents the OR of the selectors represented
// by the node selector terms.
struct NodeSelector {
	NodeSelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeSelector & other) const;
	MARSHAL_JSON;
// Required. A list of node selector terms. The terms are ORed.
	vector< NodeSelectorTerm > nodeSelectorTerms; // `json:"nodeSelectorTerms"`
};
// Node affinity is a group of node affinity scheduling rules.
struct NodeAffinity {
	NodeAffinity();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NodeAffinity & other) const;
	MARSHAL_JSON;
// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// will try to eventually evict the pod from its node.
// +optional
// RequiredDuringSchedulingRequiredDuringExecution *NodeSelector `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
// +optional
	shared_ptr< NodeSelector > requiredDuringSchedulingIgnoredDuringExecution; // `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
// +optional
	vector< PreferredSchedulingTerm > preferredDuringSchedulingIgnoredDuringExecution; // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`
};
// Affinity is a group of affinity scheduling rules.
struct Affinity {
	Affinity();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Affinity & other) const;
	MARSHAL_JSON;
// Describes node affinity scheduling rules for the pod.
// +optional
	shared_ptr< NodeAffinity > nodeAffinity; // `json:"nodeAffinity,omitempty"`
// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
// +optional
	shared_ptr< PodAffinity > podAffinity; // `json:"podAffinity,omitempty"`
// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
// +optional
	shared_ptr< PodAntiAffinity > podAntiAffinity; // `json:"podAntiAffinity,omitempty"`
};
// PodCondition contains details for the current condition of this pod.
struct PodCondition {
	PodCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodCondition & other) const;
	MARSHAL_JSON;
// Type is the type of the condition.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	PodConditionType type; // `json:"type"`
// Status is the status of the condition.
// Can be True, False, Unknown.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	ConditionStatus status; // `json:"status"`
// Last time we probed the condition.
// +optional
	goraw::Time lastProbeTime; // `json:"lastProbeTime,omitempty"`
// Last time the condition transitioned from one status to another.
// +optional
	goraw::Time lastTransitionTime; // `json:"lastTransitionTime,omitempty"`
// Unique, one-word, CamelCase reason for the condition's last transition.
// +optional
	string reason; // `json:"reason,omitempty"`
// Human-readable message indicating details about last transition.
// +optional
	string message; // `json:"message,omitempty"`
};
// ContainerStateTerminated is a terminated state of a container.
struct ContainerStateTerminated {
	ContainerStateTerminated();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerStateTerminated & other) const;
	MARSHAL_JSON;
// Exit status from the last termination of the container
	long long exitCode; // `json:"exitCode"`
// Signal from the last termination of the container
// +optional
	long long signal; // `json:"signal,omitempty"`
// (brief) reason from the last termination of the container
// +optional
	string reason; // `json:"reason,omitempty"`
// Message regarding the last termination of the container
// +optional
	string message; // `json:"message,omitempty"`
// Time at which previous execution of the container started
// +optional
	goraw::Time startedAt; // `json:"startedAt,omitempty"`
// Time at which the container last terminated
// +optional
	goraw::Time finishedAt; // `json:"finishedAt,omitempty"`
// Container's ID in the format 'docker://<container_id>'
// +optional
	string containerID; // `json:"containerID,omitempty"`
};
// ContainerStateRunning is a running state of a container.
struct ContainerStateRunning {
	ContainerStateRunning();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerStateRunning & other) const;
	MARSHAL_JSON;
// Time at which the container was last (re-)started
// +optional
	goraw::Time startedAt; // `json:"startedAt,omitempty"`
};
// ContainerStateWaiting is a waiting state of a container.
struct ContainerStateWaiting {
	ContainerStateWaiting();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerStateWaiting & other) const;
	MARSHAL_JSON;
// (brief) reason the container is not yet running.
// +optional
	string reason; // `json:"reason,omitempty"`
// Message regarding why the container is not yet running.
// +optional
	string message; // `json:"message,omitempty"`
};
// ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
struct ContainerState {
	ContainerState();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerState & other) const;
	MARSHAL_JSON;
// Details about a waiting container
// +optional
	shared_ptr< ContainerStateWaiting > waiting; // `json:"waiting,omitempty"`
// Details about a running container
// +optional
	shared_ptr< ContainerStateRunning > running; // `json:"running,omitempty"`
// Details about a terminated container
// +optional
	shared_ptr< ContainerStateTerminated > terminated; // `json:"terminated,omitempty"`
};
// ContainerStatus contains details for the current status of this container.
struct ContainerStatus {
	ContainerStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerStatus & other) const;
	MARSHAL_JSON;
// This must be a DNS_LABEL. Each container in a pod must have a unique name.
// Cannot be updated.
	string name; // `json:"name"`
// Details about the container's current condition.
// +optional
	ContainerState state; // `json:"state,omitempty"`
// Details about the container's last termination condition.
// +optional
	ContainerState lastState; // `json:"lastState"`
// Specifies whether the container has passed its readiness probe.
	bool ready; // `json:"ready"`
// The number of times the container has been restarted, currently based on
// the number of dead containers that have not yet been removed.
// Note that this is calculated from dead containers. But those containers are subject to
// garbage collection. This value will get capped at 5 by GC.
	long long restartCount; // `json:"restartCount"`
// The image the container is running.
// More info: https://kubernetes.io/docs/concepts/containers/images
// TODO(dchen1107): Which image the container is running with?
	string image; // `json:"image"`
// ImageID of the container's image.
	string imageID; // `json:"imageID"`
// Container's ID in the format 'docker://<container_id>'.
// +optional
	string containerID; // `json:"containerID,omitempty"`
// Specifies whether the container has passed its startup probe.
// Initialized as false, becomes true after startupProbe is considered successful.
// Resets to false when the container is restarted, or if kubelet loses state temporarily.
// Is always true when no startupProbe is defined.
// +optional
	shared_ptr< bool > started; // `json:"started,omitempty"`
};
// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system, especially if the node that hosts the pod cannot contact the control
// plane.
struct PodStatus {
	PodStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodStatus & other) const;
	MARSHAL_JSON;
// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
// The conditions array, the reason and message fields, and the individual container status
// arrays contain more detail about the pod's status.
// There are five possible phase values:
// 
// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
// container images has not been created. This includes time before being scheduled as
// well as time spent downloading images over the network, which could take a while.
// Running: The pod has been bound to a node, and all of the containers have been created.
// At least one container is still running, or is in the process of starting or restarting.
// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
// Failed: All containers in the pod have terminated, and at least one container has
// terminated in failure. The container either exited with non-zero status or was terminated
// by the system.
// Unknown: For some reason the state of the pod could not be obtained, typically due to an
// error in communicating with the host of the pod.
// 
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
// +optional
	PodPhase phase; // `json:"phase,omitempty"`
// Current service state of pod.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< PodCondition > conditions; // `json:"conditions,omitempty"`
// A human readable message indicating details about why the pod is in this condition.
// +optional
	string message; // `json:"message,omitempty"`
// A brief CamelCase message indicating details about why the pod is in this state.
// e.g. 'Evicted'
// +optional
	string reason; // `json:"reason,omitempty"`
// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
// scheduled right away as preemption victims receive their graceful termination periods.
// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
// give the resources on this node to a higher priority pod that is created after preemption.
// As a result, this field may be different than PodSpec.nodeName when the pod is
// scheduled.
// +optional
	string nominatedNodeName; // `json:"nominatedNodeName,omitempty"`
// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
// +optional
	string hostIP; // `json:"hostIP,omitempty"`
// IP address allocated to the pod. Routable at least within the cluster.
// Empty if not yet allocated.
// +optional
	string podIP; // `json:"podIP,omitempty"`
// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
// is empty if no IPs have been allocated yet.
// +optional
// +patchStrategy=merge
// +patchMergeKey=ip
	vector< PodIP > podIPs; // `json:"podIPs,omitempty"`
// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
// This is before the Kubelet pulled the container image(s) for the pod.
// +optional
	shared_ptr< goraw::Time > startTime; // `json:"startTime,omitempty"`
// The list has one entry per init container in the manifest. The most recent successful
// init container will have ready = true, the most recently started container will have
// startTime set.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	vector< ContainerStatus > initContainerStatuses; // `json:"initContainerStatuses"`
// The list has one entry per container in the manifest. Each entry is currently the output
// of `docker inspect`.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
// +optional
	vector< ContainerStatus > containerStatuses; // `json:"containerStatuses"`
// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
// See PodQOSClass type for available QOS classes
// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
// +optional
	PodQOSClass qosClass; // `json:"qosClass,omitempty"`
// Status for any ephemeral containers that have run in this pod.
// This field is alpha-level and is only populated by servers that enable the EphemeralContainers feature.
// +optional
	vector< ContainerStatus > ephemeralContainerStatuses; // `json:"ephemeralContainerStatuses,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
struct PodStatusResult : public apis::meta::v1::TypeMeta {
	PodStatusResult();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodStatusResult & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Most recently observed status of the pod.
// This data may not be up to date.
// Populated by the system.
// Read-only.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	PodStatus status; // `json:"status,omitempty"`
};
// ResourceRequirements describes the compute resource requirements.
struct ResourceRequirements {
	ResourceRequirements();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceRequirements & other) const;
	MARSHAL_JSON;
// Limits describes the maximum amount of compute resources allowed.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
// +optional
	ResourceList limits; // `json:"limits,omitempty"`
// Requests describes the minimum amount of compute resources required.
// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
// otherwise to an implementation-defined value.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
// +optional
	ResourceList requests; // `json:"requests,omitempty"`
};
// Adds and removes POSIX capabilities from running containers.
struct Capabilities {
	Capabilities();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Capabilities & other) const;
	MARSHAL_JSON;
// Added capabilities
// +optional
	vector< Capability > add; // `json:"add,omitempty"`
// Removed capabilities
// +optional
	vector< Capability > drop; // `json:"drop,omitempty"`
};
// SecurityContext holds security configuration that will be applied to a container.
// Some fields are present in both SecurityContext and PodSecurityContext.  When both
// are set, the values in SecurityContext take precedence.
struct SecurityContext {
	SecurityContext();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecurityContext & other) const;
	MARSHAL_JSON;
// The capabilities to add/drop when running containers.
// Defaults to the default set of capabilities granted by the container runtime.
// +optional
	shared_ptr< Capabilities > capabilities; // `json:"capabilities,omitempty"`
// Run container in privileged mode.
// Processes in privileged containers are essentially equivalent to root on the host.
// Defaults to false.
// +optional
	shared_ptr< bool > privileged; // `json:"privileged,omitempty"`
// The SELinux context to be applied to the container.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< SELinuxOptions > seLinuxOptions; // `json:"seLinuxOptions,omitempty"`
// The Windows specific settings applied to all containers.
// If unspecified, the options from the PodSecurityContext will be used.
// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< WindowsSecurityContextOptions > windowsOptions; // `json:"windowsOptions,omitempty"`
// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in PodSecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< long long > runAsUser; // `json:"runAsUser,omitempty"`
// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in PodSecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< long long > runAsGroup; // `json:"runAsGroup,omitempty"`
// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in PodSecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
// +optional
	shared_ptr< bool > runAsNonRoot; // `json:"runAsNonRoot,omitempty"`
// Whether this container has a read-only root filesystem.
// Default is false.
// +optional
	shared_ptr< bool > readOnlyRootFilesystem; // `json:"readOnlyRootFilesystem,omitempty"`
// AllowPrivilegeEscalation controls whether a process can gain more
// privileges than its parent process. This bool directly controls if
// the no_new_privs flag will be set on the container process.
// AllowPrivilegeEscalation is true always when the container is:
// 1) run as Privileged
// 2) has CAP_SYS_ADMIN
// +optional
	shared_ptr< bool > allowPrivilegeEscalation; // `json:"allowPrivilegeEscalation,omitempty"`
// procMount denotes the type of proc mount to use for the containers.
// The default is DefaultProcMount which uses the container runtime defaults for
// readonly paths and masked paths.
// This requires the ProcMountType feature flag to be enabled.
// +optional
	shared_ptr< ProcMountType > procMount; // `json:"procMount,omitempty"`
// The seccomp options to use by this container. If seccomp options are
// provided at both the pod & container level, the container options
// override the pod options.
// +optional
	shared_ptr< SeccompProfile > seccompProfile; // `json:"seccompProfile,omitempty"`
};
// ExecAction describes a "run in container" action.
struct ExecAction {
	ExecAction();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ExecAction & other) const;
	MARSHAL_JSON;
// Command is the command line to execute inside the container, the working directory for the
// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
// a shell, you need to explicitly call out to that shell.
// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
// +optional
	vector< string > command; // `json:"command,omitempty"`
};
// TCPSocketAction describes an action based on opening a socket
struct TCPSocketAction {
	TCPSocketAction();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const TCPSocketAction & other) const;
	MARSHAL_JSON;
// Number or name of the port to access on the container.
// Number must be in the range 1 to 65535.
// Name must be an IANA_SVC_NAME.
	apis::goraw::IntOrString port; // `json:"port"`
// Optional: Host name to connect to, defaults to the pod IP.
// +optional
	string host; // `json:"host,omitempty"`
};
// HTTPHeader describes a custom header to be used in HTTP probes
struct HTTPHeader {
	HTTPHeader();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const HTTPHeader & other) const;
	MARSHAL_JSON;
// The header field name
	string name; // `json:"name"`
// The header field value
	string value; // `json:"value"`
};
// HTTPGetAction describes an action based on HTTP Get requests.
struct HTTPGetAction {
	HTTPGetAction();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const HTTPGetAction & other) const;
	MARSHAL_JSON;
// Path to access on the HTTP server.
// +optional
	string path; // `json:"path,omitempty"`
// Name or number of the port to access on the container.
// Number must be in the range 1 to 65535.
// Name must be an IANA_SVC_NAME.
	apis::goraw::IntOrString port; // `json:"port"`
// Host name to connect to, defaults to the pod IP. You probably want to set
// "Host" in httpHeaders instead.
// +optional
	string host; // `json:"host,omitempty"`
// Scheme to use for connecting to the host.
// Defaults to HTTP.
// +optional
	URIScheme scheme; // `json:"scheme,omitempty"`
// Custom headers to set in the request. HTTP allows repeated headers.
// +optional
	vector< HTTPHeader > httpHeaders; // `json:"httpHeaders,omitempty"`
};
// Handler defines a specific action that should be taken
// TODO: pass structured data to these actions, and document that data here.
struct Handler {
	Handler();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Handler & other) const;
	MARSHAL_JSON;
// One and only one of the following should be specified.
// Exec specifies the action to take.
// +optional
	shared_ptr< ExecAction > exec; // `json:"exec,omitempty"`
// HTTPGet specifies the http request to perform.
// +optional
	shared_ptr< HTTPGetAction > httpGet; // `json:"httpGet,omitempty"`
// TCPSocket specifies an action involving a TCP port.
// TCP hooks not yet supported
// TODO: implement a realistic TCP lifecycle hook
// +optional
	shared_ptr< TCPSocketAction > tcpSocket; // `json:"tcpSocket,omitempty"`
};
// Lifecycle describes actions that the management system should take in response to container lifecycle
// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
// until the action is complete, unless the container process fails, in which case the handler is aborted.
struct Lifecycle {
	Lifecycle();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Lifecycle & other) const;
	MARSHAL_JSON;
// PostStart is called immediately after a container is created. If the handler fails,
// the container is terminated and restarted according to its restart policy.
// Other management of the container blocks until the hook completes.
// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
// +optional
	shared_ptr< Handler > postStart; // `json:"postStart,omitempty"`
// PreStop is called immediately before a container is terminated due to an
// API request or management event such as liveness/startup probe failure,
// preemption, resource contention, etc. The handler is not called if the
// container crashes or exits. The reason for termination is passed to the
// handler. The Pod's termination grace period countdown begins before the
// PreStop hooked is executed. Regardless of the outcome of the handler, the
// container will eventually terminate within the Pod's termination grace
// period. Other management of the container blocks until the hook completes
// or until the termination grace period is reached.
// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
// +optional
	shared_ptr< Handler > preStop; // `json:"preStop,omitempty"`
};
// Probe describes a health check to be performed against a container to determine whether it is
// alive or ready to receive traffic.
struct Probe : public Handler {
	Probe();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Probe & other) const;
	MARSHAL_JSON;
// Number of seconds after the container has started before liveness probes are initiated.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
// +optional
	long long initialDelaySeconds; // `json:"initialDelaySeconds,omitempty"`
// Number of seconds after which the probe times out.
// Defaults to 1 second. Minimum value is 1.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
// +optional
	long long timeoutSeconds; // `json:"timeoutSeconds,omitempty"`
// How often (in seconds) to perform the probe.
// Default to 10 seconds. Minimum value is 1.
// +optional
	long long periodSeconds; // `json:"periodSeconds,omitempty"`
// Minimum consecutive successes for the probe to be considered successful after having failed.
// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
// +optional
	long long successThreshold; // `json:"successThreshold,omitempty"`
// Minimum consecutive failures for the probe to be considered failed after having succeeded.
// Defaults to 3. Minimum value is 1.
// +optional
	long long failureThreshold; // `json:"failureThreshold,omitempty"`
};
// SecretEnvSource selects a Secret to populate the environment
// variables with.
// 
// The contents of the target Secret's Data field will represent the
// key-value pairs as environment variables.
struct SecretEnvSource : public LocalObjectReference {
	SecretEnvSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretEnvSource & other) const;
	MARSHAL_JSON;
// Specify whether the Secret must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// ConfigMapEnvSource selects a ConfigMap to populate the environment
// variables with.
// 
// The contents of the target ConfigMap's Data field will represent the
// key-value pairs as environment variables.
struct ConfigMapEnvSource : public LocalObjectReference {
	ConfigMapEnvSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapEnvSource & other) const;
	MARSHAL_JSON;
// Specify whether the ConfigMap must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// EnvFromSource represents the source of a set of ConfigMaps
struct EnvFromSource {
	EnvFromSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EnvFromSource & other) const;
	MARSHAL_JSON;
// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
// +optional
	string prefix; // `json:"prefix,omitempty"`
// The ConfigMap to select from
// +optional
	shared_ptr< ConfigMapEnvSource > configMapRef; // `json:"configMapRef,omitempty"`
// The Secret to select from
// +optional
	shared_ptr< SecretEnvSource > secretRef; // `json:"secretRef,omitempty"`
};
// SecretKeySelector selects a key of a Secret.
struct SecretKeySelector : public LocalObjectReference {
	SecretKeySelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretKeySelector & other) const;
	MARSHAL_JSON;
// The key of the secret to select from.  Must be a valid secret key.
	string key; // `json:"key"`
// Specify whether the Secret or its key must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// Selects a key from a ConfigMap.
struct ConfigMapKeySelector : public LocalObjectReference {
	ConfigMapKeySelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapKeySelector & other) const;
	MARSHAL_JSON;
// The key to select.
	string key; // `json:"key"`
// Specify whether the ConfigMap or its key must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// ResourceFieldSelector represents container resources (cpu, memory) and their output format
struct ResourceFieldSelector {
	ResourceFieldSelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ResourceFieldSelector & other) const;
	MARSHAL_JSON;
// Container name: required for volumes, optional for env vars
// +optional
	string containerName; // `json:"containerName,omitempty"`
// Required: resource to select
	string resource; // `json:"resource"`
// Specifies the output format of the exposed resources, defaults to "1"
// +optional
	apis::goraw::Quantity divisor; // `json:"divisor,omitempty"`
};
// ObjectFieldSelector selects an APIVersioned field of an object.
struct ObjectFieldSelector {
	ObjectFieldSelector();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ObjectFieldSelector & other) const;
	MARSHAL_JSON;
// Version of the schema the FieldPath is written in terms of, defaults to "v1".
// +optional
	string apiVersion; // `json:"apiVersion,omitempty"`
// Path of the field to select in the specified API version.
	string fieldPath; // `json:"fieldPath"`
};
// DownwardAPIVolumeFile represents information to create the file containing the pod field
struct DownwardAPIVolumeFile {
	DownwardAPIVolumeFile();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const DownwardAPIVolumeFile & other) const;
	MARSHAL_JSON;
// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
	string path; // `json:"path"`
// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
// +optional
	shared_ptr< ObjectFieldSelector > fieldRef; // `json:"fieldRef,omitempty"`
// Selects a resource of the container: only resources limits and requests
// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
// +optional
	shared_ptr< ResourceFieldSelector > resourceFieldRef; // `json:"resourceFieldRef,omitempty"`
// Optional: mode bits used to set permissions on this file, must be an octal value
// between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
// If not specified, the volume defaultMode will be used.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > mode; // `json:"mode,omitempty"`
};
// Represents downward API info for projecting into a projected volume.
// Note that this is identical to a downwardAPI volume source without the default
// mode.
struct DownwardAPIProjection {
	DownwardAPIProjection();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const DownwardAPIProjection & other) const;
	MARSHAL_JSON;
// Items is a list of DownwardAPIVolume file
// +optional
	vector< DownwardAPIVolumeFile > items; // `json:"items,omitempty"`
};
// DownwardAPIVolumeSource represents a volume containing downward API info.
// Downward API volumes support ownership management and SELinux relabeling.
struct DownwardAPIVolumeSource {
	DownwardAPIVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const DownwardAPIVolumeSource & other) const;
	MARSHAL_JSON;
// Items is a list of downward API volume file
// +optional
	vector< DownwardAPIVolumeFile > items; // `json:"items,omitempty"`
// Optional: mode bits to use on created files by default. Must be a
// Optional: mode bits used to set permissions on created files by default.
// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
// Defaults to 0644.
// Directories within the path are not affected by this setting.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > defaultMode; // `json:"defaultMode,omitempty"`
};
// EnvVarSource represents a source for the value of an EnvVar.
struct EnvVarSource {
	EnvVarSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EnvVarSource & other) const;
	MARSHAL_JSON;
// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
// +optional
	shared_ptr< ObjectFieldSelector > fieldRef; // `json:"fieldRef,omitempty"`
// Selects a resource of the container: only resources limits and requests
// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
// +optional
	shared_ptr< ResourceFieldSelector > resourceFieldRef; // `json:"resourceFieldRef,omitempty"`
// Selects a key of a ConfigMap.
// +optional
	shared_ptr< ConfigMapKeySelector > configMapKeyRef; // `json:"configMapKeyRef,omitempty"`
// Selects a key of a secret in the pod's namespace
// +optional
	shared_ptr< SecretKeySelector > secretKeyRef; // `json:"secretKeyRef,omitempty"`
};
// EnvVar represents an environment variable present in a Container.
struct EnvVar {
	EnvVar();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EnvVar & other) const;
	MARSHAL_JSON;
// Name of the environment variable. Must be a C_IDENTIFIER.
	string name; // `json:"name"`
// Optional: no more than one of the following may be specified.
// Variable references $(VAR_NAME) are expanded
// using the previous defined environment variables in the container and
// any service environment variables. If a variable cannot be resolved,
// the reference in the input string will be unchanged. The $(VAR_NAME)
// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
// references will never be expanded, regardless of whether the variable
// exists or not.
// Defaults to "".
// +optional
	string value; // `json:"value,omitempty"`
// Source for the environment variable's value. Cannot be used if value is not empty.
// +optional
	shared_ptr< EnvVarSource > valueFrom; // `json:"valueFrom,omitempty"`
};
// volumeDevice describes a mapping of a raw block device within a container.
struct VolumeDevice {
	VolumeDevice();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VolumeDevice & other) const;
	MARSHAL_JSON;
// name must match the name of a persistentVolumeClaim in the pod
	string name; // `json:"name"`
// devicePath is the path inside of the container that the device will be mapped to.
	string devicePath; // `json:"devicePath"`
};
// VolumeMount describes a mounting of a Volume within a container.
struct VolumeMount {
	VolumeMount();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VolumeMount & other) const;
	MARSHAL_JSON;
// This must match the Name of a Volume.
	string name; // `json:"name"`
// Mounted read-only if true, read-write otherwise (false or unspecified).
// Defaults to false.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Path within the container at which the volume should be mounted.  Must
// not contain ':'.
	string mountPath; // `json:"mountPath"`
// Path within the volume from which the container's volume should be mounted.
// Defaults to "" (volume's root).
// +optional
	string subPath; // `json:"subPath,omitempty"`
// mountPropagation determines how mounts are propagated from the host
// to container and the other way around.
// When not set, MountPropagationNone is used.
// This field is beta in 1.10.
// +optional
	shared_ptr< MountPropagationMode > mountPropagation; // `json:"mountPropagation,omitempty"`
// Expanded path within the volume from which the container's volume should be mounted.
// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
// Defaults to "" (volume's root).
// SubPathExpr and SubPath are mutually exclusive.
// +optional
	string subPathExpr; // `json:"subPathExpr,omitempty"`
};
// ContainerPort represents a network port in a single container.
struct ContainerPort {
	ContainerPort();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ContainerPort & other) const;
	MARSHAL_JSON;
// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
// named port in a pod must have a unique name. Name for the port that can be
// referred to by services.
// +optional
	string name; // `json:"name,omitempty"`
// Number of port to expose on the host.
// If specified, this must be a valid port number, 0 < x < 65536.
// If HostNetwork is specified, this must match ContainerPort.
// Most containers do not need this.
// +optional
	long long hostPort; // `json:"hostPort,omitempty"`
// Number of port to expose on the pod's IP address.
// This must be a valid port number, 0 < x < 65536.
	long long containerPort; // `json:"containerPort"`
// Protocol for port. Must be UDP, TCP, or SCTP.
// Defaults to "TCP".
// +optional
	Protocol protocol; // `json:"protocol,omitempty"`
// What host IP to bind the external port to.
// +optional
	string hostIP; // `json:"hostIP,omitempty"`
};
// EphemeralContainerCommon is a copy of all fields in Container to be inlined in
// EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
// to Container and allows separate documentation for the fields of EphemeralContainer.
// When a new field is added to Container it must be added here as well.
struct EphemeralContainerCommon {
	EphemeralContainerCommon();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EphemeralContainerCommon & other) const;
	MARSHAL_JSON;
// Name of the ephemeral container specified as a DNS_LABEL.
// This name must be unique among all containers, init containers and ephemeral containers.
	string name; // `json:"name"`
// Docker image name.
// More info: https://kubernetes.io/docs/concepts/containers/images
	string image; // `json:"image,omitempty"`
// Entrypoint array. Not executed within a shell.
// The docker image's ENTRYPOINT is used if this is not provided.
// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
// regardless of whether the variable exists or not.
// Cannot be updated.
// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
// +optional
	vector< string > command; // `json:"command,omitempty"`
// Arguments to the entrypoint.
// The docker image's CMD is used if this is not provided.
// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
// regardless of whether the variable exists or not.
// Cannot be updated.
// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
// +optional
	vector< string > args; // `json:"args,omitempty"`
// Container's working directory.
// If not specified, the container runtime's default will be used, which
// might be configured in the container image.
// Cannot be updated.
// +optional
	string workingDir; // `json:"workingDir,omitempty"`
// Ports are not allowed for ephemeral containers.
	vector< ContainerPort > ports; // `json:"ports,omitempty"`
// List of sources to populate environment variables in the container.
// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
// will be reported as an event when the container is starting. When a key exists in multiple
// sources, the value associated with the last source will take precedence.
// Values defined by an Env with a duplicate key will take precedence.
// Cannot be updated.
// +optional
	vector< EnvFromSource > envFrom; // `json:"envFrom,omitempty"`
// List of environment variables to set in the container.
// Cannot be updated.
// +optional
// +patchMergeKey=name
// +patchStrategy=merge
	vector< EnvVar > env; // `json:"env,omitempty"`
// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
// already allocated to the pod.
// +optional
	ResourceRequirements resources; // `json:"resources,omitempty"`
// Pod volumes to mount into the container's filesystem.
// Cannot be updated.
// +optional
// +patchMergeKey=mountPath
// +patchStrategy=merge
	vector< VolumeMount > volumeMounts; // `json:"volumeMounts,omitempty"`
// volumeDevices is the list of block devices to be used by the container.
// +patchMergeKey=devicePath
// +patchStrategy=merge
// +optional
	vector< VolumeDevice > volumeDevices; // `json:"volumeDevices,omitempty"`
// Probes are not allowed for ephemeral containers.
// +optional
	shared_ptr< Probe > livenessProbe; // `json:"livenessProbe,omitempty"`
// Probes are not allowed for ephemeral containers.
// +optional
	shared_ptr< Probe > readinessProbe; // `json:"readinessProbe,omitempty"`
// Probes are not allowed for ephemeral containers.
// +optional
	shared_ptr< Probe > startupProbe; // `json:"startupProbe,omitempty"`
// Lifecycle is not allowed for ephemeral containers.
// +optional
	shared_ptr< Lifecycle > lifecycle; // `json:"lifecycle,omitempty"`
// Optional: Path at which the file to which the container's termination message
// will be written is mounted into the container's filesystem.
// Message written is intended to be brief final status, such as an assertion failure message.
// Will be truncated by the node if greater than 4096 bytes. The total message length across
// all containers will be limited to 12kb.
// Defaults to /dev/termination-log.
// Cannot be updated.
// +optional
	string terminationMessagePath; // `json:"terminationMessagePath,omitempty"`
// Indicate how the termination message should be populated. File will use the contents of
// terminationMessagePath to populate the container status message on both success and failure.
// FallbackToLogsOnError will use the last chunk of container log output if the termination
// message file is empty and the container exited with an error.
// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
// Defaults to File.
// Cannot be updated.
// +optional
	TerminationMessagePolicy terminationMessagePolicy; // `json:"terminationMessagePolicy,omitempty"`
// Image pull policy.
// One of Always, Never, IfNotPresent.
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
// +optional
	PullPolicy imagePullPolicy; // `json:"imagePullPolicy,omitempty"`
// SecurityContext is not allowed for ephemeral containers.
// +optional
	shared_ptr< SecurityContext > securityContext; // `json:"securityContext,omitempty"`
// Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
// and shouldn't be used for general purpose containers.
// Whether this container should allocate a buffer for stdin in the container runtime. If this
// is not set, reads from stdin in the container will always result in EOF.
// Default is false.
// +optional
	bool Stdin; // `json:"stdin,omitempty"`
// Whether the container runtime should close the stdin channel after it has been opened by
// a single attach. When stdin is true the stdin stream will remain open across multiple attach
// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
// at which time stdin is closed and remains closed until the container is restarted. If this
// flag is false, a container processes that reads from stdin will never receive an EOF.
// Default is false
// +optional
	bool stdinOnce; // `json:"stdinOnce,omitempty"`
// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
// Default is false.
// +optional
	bool tty; // `json:"tty,omitempty"`
};
// EphemeralContainerCommon converts to Container. All fields must be kept in sync between
// these two types.
// An EphemeralContainer is a container that may be added temporarily to an existing pod for
// user-initiated activities such as debugging. Ephemeral containers have no resource or
// scheduling guarantees, and they will not be restarted when they exit or when a pod is
// removed or restarted. If an ephemeral container causes a pod to exceed its resource
// allocation, the pod may be evicted.
// Ephemeral containers may not be added by directly updating the pod spec. They must be added
// via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
// once added.
// This is an alpha feature enabled by the EphemeralContainers feature flag.
struct EphemeralContainer : public EphemeralContainerCommon {
	EphemeralContainer();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EphemeralContainer & other) const;
	MARSHAL_JSON;
// If set, the name of the container from PodSpec that this ephemeral container targets.
// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
// If not set then the ephemeral container is run in whatever namespaces are shared
// for the pod. Note that the container runtime must support this feature.
// +optional
	string targetContainerName; // `json:"targetContainerName,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// A list of ephemeral containers used with the Pod ephemeralcontainers subresource.
struct EphemeralContainers : public apis::meta::v1::TypeMeta {
	EphemeralContainers();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EphemeralContainers & other) const;
	MARSHAL_JSON;
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// A list of ephemeral containers associated with this pod. New ephemeral containers
// may be appended to this list, but existing ephemeral containers may not be removed
// or modified.
// +patchMergeKey=name
// +patchStrategy=merge
	vector< EphemeralContainer > ephemeralContainers; // `json:"ephemeralContainers"`
};
// A single application container that you want to run within a pod.
struct Container {
	Container();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Container & other) const;
	MARSHAL_JSON;
// Name of the container specified as a DNS_LABEL.
// Each container in a pod must have a unique name (DNS_LABEL).
// Cannot be updated.
	string name; // `json:"name"`
// Docker image name.
// More info: https://kubernetes.io/docs/concepts/containers/images
// This field is optional to allow higher level config management to default or override
// container images in workload controllers like Deployments and StatefulSets.
// +optional
	string image; // `json:"image,omitempty"`
// Entrypoint array. Not executed within a shell.
// The docker image's ENTRYPOINT is used if this is not provided.
// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
// regardless of whether the variable exists or not.
// Cannot be updated.
// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
// +optional
	vector< string > command; // `json:"command,omitempty"`
// Arguments to the entrypoint.
// The docker image's CMD is used if this is not provided.
// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
// regardless of whether the variable exists or not.
// Cannot be updated.
// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
// +optional
	vector< string > args; // `json:"args,omitempty"`
// Container's working directory.
// If not specified, the container runtime's default will be used, which
// might be configured in the container image.
// Cannot be updated.
// +optional
	string workingDir; // `json:"workingDir,omitempty"`
// List of ports to expose from the container. Exposing a port here gives
// the system additional information about the network connections a
// container uses, but is primarily informational. Not specifying a port here
// DOES NOT prevent that port from being exposed. Any port which is
// listening on the default "0.0.0.0" address inside a container will be
// accessible from the network.
// Cannot be updated.
// +optional
// +patchMergeKey=containerPort
// +patchStrategy=merge
// +listType=map
// +listMapKey=containerPort
// +listMapKey=protocol
	vector< ContainerPort > ports; // `json:"ports,omitempty"`
// List of sources to populate environment variables in the container.
// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
// will be reported as an event when the container is starting. When a key exists in multiple
// sources, the value associated with the last source will take precedence.
// Values defined by an Env with a duplicate key will take precedence.
// Cannot be updated.
// +optional
	vector< EnvFromSource > envFrom; // `json:"envFrom,omitempty"`
// List of environment variables to set in the container.
// Cannot be updated.
// +optional
// +patchMergeKey=name
// +patchStrategy=merge
	vector< EnvVar > env; // `json:"env,omitempty"`
// Compute Resources required by this container.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
// +optional
	ResourceRequirements resources; // `json:"resources,omitempty"`
// Pod volumes to mount into the container's filesystem.
// Cannot be updated.
// +optional
// +patchMergeKey=mountPath
// +patchStrategy=merge
	vector< VolumeMount > volumeMounts; // `json:"volumeMounts,omitempty"`
// volumeDevices is the list of block devices to be used by the container.
// +patchMergeKey=devicePath
// +patchStrategy=merge
// +optional
	vector< VolumeDevice > volumeDevices; // `json:"volumeDevices,omitempty"`
// Periodic probe of container liveness.
// Container will be restarted if the probe fails.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
// +optional
	shared_ptr< Probe > livenessProbe; // `json:"livenessProbe,omitempty"`
// Periodic probe of container service readiness.
// Container will be removed from service endpoints if the probe fails.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
// +optional
	shared_ptr< Probe > readinessProbe; // `json:"readinessProbe,omitempty"`
// StartupProbe indicates that the Pod has successfully initialized.
// If specified, no other probes are executed until this completes successfully.
// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
// when it might take a long time to load data or warm a cache, than during steady-state operation.
// This cannot be updated.
// This is a beta feature enabled by the StartupProbe feature flag.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
// +optional
	shared_ptr< Probe > startupProbe; // `json:"startupProbe,omitempty"`
// Actions that the management system should take in response to container lifecycle events.
// Cannot be updated.
// +optional
	shared_ptr< Lifecycle > lifecycle; // `json:"lifecycle,omitempty"`
// Optional: Path at which the file to which the container's termination message
// will be written is mounted into the container's filesystem.
// Message written is intended to be brief final status, such as an assertion failure message.
// Will be truncated by the node if greater than 4096 bytes. The total message length across
// all containers will be limited to 12kb.
// Defaults to /dev/termination-log.
// Cannot be updated.
// +optional
	string terminationMessagePath; // `json:"terminationMessagePath,omitempty"`
// Indicate how the termination message should be populated. File will use the contents of
// terminationMessagePath to populate the container status message on both success and failure.
// FallbackToLogsOnError will use the last chunk of container log output if the termination
// message file is empty and the container exited with an error.
// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
// Defaults to File.
// Cannot be updated.
// +optional
	TerminationMessagePolicy terminationMessagePolicy; // `json:"terminationMessagePolicy,omitempty"`
// Image pull policy.
// One of Always, Never, IfNotPresent.
// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
// +optional
	PullPolicy imagePullPolicy; // `json:"imagePullPolicy,omitempty"`
// Security options the pod should run with.
// More info: https://kubernetes.io/docs/concepts/policy/security-context/
// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
// +optional
	shared_ptr< SecurityContext > securityContext; // `json:"securityContext,omitempty"`
// Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
// and shouldn't be used for general purpose containers.
// Whether this container should allocate a buffer for stdin in the container runtime. If this
// is not set, reads from stdin in the container will always result in EOF.
// Default is false.
// +optional
	bool Stdin; // `json:"stdin,omitempty"`
// Whether the container runtime should close the stdin channel after it has been opened by
// a single attach. When stdin is true the stdin stream will remain open across multiple attach
// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
// at which time stdin is closed and remains closed until the container is restarted. If this
// flag is false, a container processes that reads from stdin will never receive an EOF.
// Default is false
// +optional
	bool stdinOnce; // `json:"stdinOnce,omitempty"`
// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
// Default is false.
// +optional
	bool tty; // `json:"tty,omitempty"`
};
// Represents a source location of a volume to mount, managed by an external CSI driver
struct CSIVolumeSource {
	CSIVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CSIVolumeSource & other) const;
	MARSHAL_JSON;
// Driver is the name of the CSI driver that handles this volume.
// Consult with your admin for the correct name as registered in the cluster.
	string driver; // `json:"driver"`
// Specifies a read-only configuration for the volume.
// Defaults to false (read/write).
// +optional
	shared_ptr< bool > readOnly; // `json:"readOnly,omitempty"`
// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
// If not provided, the empty value is passed to the associated CSI driver
// which will determine the default filesystem to apply.
// +optional
	shared_ptr< string > fsType; // `json:"fsType,omitempty"`
// VolumeAttributes stores driver-specific properties that are passed to the CSI
// driver. Consult your driver's documentation for supported values.
// +optional
	map< string , string > volumeAttributes; // `json:"volumeAttributes,omitempty"`
// NodePublishSecretRef is a reference to the secret object containing
// sensitive information to pass to the CSI driver to complete the CSI
// NodePublishVolume and NodeUnpublishVolume calls.
// This field is optional, and  may be empty if no secret is required. If the
// secret object contains more than one secret, all secret references are passed.
// +optional
	shared_ptr< LocalObjectReference > nodePublishSecretRef; // `json:"nodePublishSecretRef,omitempty"`
};
// Local represents directly-attached storage with node affinity (Beta feature)
struct LocalVolumeSource {
	LocalVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const LocalVolumeSource & other) const;
	MARSHAL_JSON;
// The full path to the volume on the node.
// It can be either a directory or block device (disk, partition, ...).
	string path; // `json:"path"`
// Filesystem type to mount.
// It applies only when the Path is a block device.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a fileystem if unspecified.
// +optional
	shared_ptr< string > fsType; // `json:"fsType,omitempty"`
};
// Maps a string key to a path within a volume.
struct KeyToPath {
	KeyToPath();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const KeyToPath & other) const;
	MARSHAL_JSON;
// The key to project.
	string key; // `json:"key"`
// The relative path of the file to map the key to.
// May not be an absolute path.
// May not contain the path element '..'.
// May not start with the string '..'.
	string path; // `json:"path"`
// Optional: mode bits used to set permissions on this file.
// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
// If not specified, the volume defaultMode will be used.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > mode; // `json:"mode,omitempty"`
};
// ServiceAccountTokenProjection represents a projected service account token
// volume. This projection can be used to insert a service account token into
// the pods runtime filesystem for use against APIs (Kubernetes API Server or
// otherwise).
struct ServiceAccountTokenProjection {
	ServiceAccountTokenProjection();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ServiceAccountTokenProjection & other) const;
	MARSHAL_JSON;
// Audience is the intended audience of the token. A recipient of a token
// must identify itself with an identifier specified in the audience of the
// token, and otherwise should reject the token. The audience defaults to the
// identifier of the apiserver.
// +optional
	string audience; // `json:"audience,omitempty"`
// ExpirationSeconds is the requested duration of validity of the service
// account token. As the token approaches expiration, the kubelet volume
// plugin will proactively rotate the service account token. The kubelet will
// start trying to rotate the token if the token is older than 80 percent of
// its time to live or if the token is older than 24 hours.Defaults to 1 hour
// and must be at least 10 minutes.
// +optional
	shared_ptr< long long > expirationSeconds; // `json:"expirationSeconds,omitempty"`
// Path is the path relative to the mount point of the file to project the
// token into.
	string path; // `json:"path"`
};
// Adapts a ConfigMap into a projected volume.
// 
// The contents of the target ConfigMap's Data field will be presented in a
// projected volume as files using the keys in the Data field as the file names,
// unless the items element is populated with specific mappings of keys to paths.
// Note that this is identical to a configmap volume source without the default
// mode.
struct ConfigMapProjection : public LocalObjectReference {
	ConfigMapProjection();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapProjection & other) const;
	MARSHAL_JSON;
// If unspecified, each key-value pair in the Data field of the referenced
// ConfigMap will be projected into the volume as a file whose name is the
// key and content is the value. If specified, the listed keys will be
// projected into the specified paths, and unlisted keys will not be
// present. If a key is specified which is not present in the ConfigMap,
// the volume setup will error unless it is marked optional. Paths must be
// relative and may not contain the '..' path or start with '..'.
// +optional
	vector< KeyToPath > items; // `json:"items,omitempty"`
// Specify whether the ConfigMap or its keys must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// Adapts a ConfigMap into a volume.
// 
// The contents of the target ConfigMap's Data field will be presented in a
// volume as files using the keys in the Data field as the file names, unless
// the items element is populated with specific mappings of keys to paths.
// ConfigMap volumes support ownership management and SELinux relabeling.
struct ConfigMapVolumeSource : public LocalObjectReference {
	ConfigMapVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ConfigMapVolumeSource & other) const;
	MARSHAL_JSON;
// If unspecified, each key-value pair in the Data field of the referenced
// ConfigMap will be projected into the volume as a file whose name is the
// key and content is the value. If specified, the listed keys will be
// projected into the specified paths, and unlisted keys will not be
// present. If a key is specified which is not present in the ConfigMap,
// the volume setup will error unless it is marked optional. Paths must be
// relative and may not contain the '..' path or start with '..'.
// +optional
	vector< KeyToPath > items; // `json:"items,omitempty"`
// Optional: mode bits used to set permissions on created files by default.
// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
// Defaults to 0644.
// Directories within the path are not affected by this setting.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > defaultMode; // `json:"defaultMode,omitempty"`
// Specify whether the ConfigMap or its keys must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// Represents a StorageOS persistent volume resource.
struct StorageOSPersistentVolumeSource {
	StorageOSPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const StorageOSPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// VolumeName is the human-readable name of the StorageOS volume.  Volume
// names are only unique within a namespace.
	string volumeName; // `json:"volumeName,omitempty"`
// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
// namespace is specified then the Pod's namespace will be used.  This allows the
// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
// Set VolumeName to any name to override the default behaviour.
// Set to "default" if you are not using namespaces within StorageOS.
// Namespaces that do not pre-exist within StorageOS will be created.
// +optional
	string volumeNamespace; // `json:"volumeNamespace,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// SecretRef specifies the secret to use for obtaining the StorageOS API
// credentials.  If not specified, default values will be attempted.
// +optional
	shared_ptr< ObjectReference > secretRef; // `json:"secretRef,omitempty"`
};
// Represents a StorageOS persistent volume resource.
struct StorageOSVolumeSource {
	StorageOSVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const StorageOSVolumeSource & other) const;
	MARSHAL_JSON;
// VolumeName is the human-readable name of the StorageOS volume.  Volume
// names are only unique within a namespace.
	string volumeName; // `json:"volumeName,omitempty"`
// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
// namespace is specified then the Pod's namespace will be used.  This allows the
// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
// Set VolumeName to any name to override the default behaviour.
// Set to "default" if you are not using namespaces within StorageOS.
// Namespaces that do not pre-exist within StorageOS will be created.
// +optional
	string volumeNamespace; // `json:"volumeNamespace,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// SecretRef specifies the secret to use for obtaining the StorageOS API
// credentials.  If not specified, default values will be attempted.
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
};
// ScaleIOVolumeSource represents a persistent ScaleIO volume
struct ScaleIOVolumeSource {
	ScaleIOVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ScaleIOVolumeSource & other) const;
	MARSHAL_JSON;
// The host address of the ScaleIO API Gateway.
	string gateway; // `json:"gateway"`
// The name of the storage system as configured in ScaleIO.
	string system; // `json:"system"`
// SecretRef references to the secret for ScaleIO user and other
// sensitive information. If this is not provided, Login operation will fail.
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef"`
// Flag to enable/disable SSL communication with Gateway, default false
// +optional
	bool sslEnabled; // `json:"sslEnabled,omitempty"`
// The name of the ScaleIO Protection Domain for the configured storage.
// +optional
	string protectionDomain; // `json:"protectionDomain,omitempty"`
// The ScaleIO Storage Pool associated with the protection domain.
// +optional
	string storagePool; // `json:"storagePool,omitempty"`
// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
// Default is ThinProvisioned.
// +optional
	string storageMode; // `json:"storageMode,omitempty"`
// The name of a volume already created in the ScaleIO system
// that is associated with this volume source.
	string volumeName; // `json:"volumeName,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs".
// Default is "xfs".
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// PortworxVolumeSource represents a Portworx volume resource.
struct PortworxVolumeSource {
	PortworxVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PortworxVolumeSource & other) const;
	MARSHAL_JSON;
// VolumeID uniquely identifies a Portworx volume
	string volumeID; // `json:"volumeID"`
// FSType represents the filesystem type to mount
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
	string fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
struct AzureDiskVolumeSource {
	AzureDiskVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AzureDiskVolumeSource & other) const;
	MARSHAL_JSON;
// The Name of the data disk in the blob storage
	string diskName; // `json:"diskName"`
// The URI the data disk in the blob storage
	string diskURI; // `json:"diskURI"`
// Host Caching mode: None, Read Only, Read Write.
// +optional
	shared_ptr< AzureDataDiskCachingMode > cachingMode; // `json:"cachingMode,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// +optional
	shared_ptr< string > fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	shared_ptr< bool > readOnly; // `json:"readOnly,omitempty"`
// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
	shared_ptr< AzureDataDiskKind > kind; // `json:"kind,omitempty"`
};
// Represents a Photon Controller persistent disk resource.
struct PhotonPersistentDiskVolumeSource {
	PhotonPersistentDiskVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PhotonPersistentDiskVolumeSource & other) const;
	MARSHAL_JSON;
// ID that identifies Photon Controller persistent disk
	string pdID; // `json:"pdID"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	string fsType; // `json:"fsType,omitempty"`
};
// Represents a vSphere volume resource.
struct VsphereVirtualDiskVolumeSource {
	VsphereVirtualDiskVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VsphereVirtualDiskVolumeSource & other) const;
	MARSHAL_JSON;
// Path that identifies vSphere volume vmdk
	string volumePath; // `json:"volumePath"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Storage Policy Based Management (SPBM) profile name.
// +optional
	string storagePolicyName; // `json:"storagePolicyName,omitempty"`
// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
// +optional
	string storagePolicyID; // `json:"storagePolicyID,omitempty"`
};
// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
struct AzureFilePersistentVolumeSource {
	AzureFilePersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AzureFilePersistentVolumeSource & other) const;
	MARSHAL_JSON;
// the name of secret that contains Azure Storage Account Name and Key
	string secretName; // `json:"secretName"`
// Share Name
	string shareName; // `json:"shareName"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// the namespace of the secret that contains Azure Storage Account Name and Key
// default is the same as the Pod
// +optional
	shared_ptr< string > secretNamespace; // `json:"secretNamespace"`
};
// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
struct AzureFileVolumeSource {
	AzureFileVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AzureFileVolumeSource & other) const;
	MARSHAL_JSON;
// the name of secret that contains Azure Storage Account Name and Key
	string secretName; // `json:"secretName"`
// Share Name
	string shareName; // `json:"shareName"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a Fibre Channel volume.
// Fibre Channel volumes can only be mounted as read/write once.
// Fibre Channel volumes support ownership management and SELinux relabeling.
struct FCVolumeSource {
	FCVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const FCVolumeSource & other) const;
	MARSHAL_JSON;
// Optional: FC target worldwide names (WWNs)
// +optional
	vector< string > targetWWNs; // `json:"targetWWNs,omitempty"`
// Optional: FC target lun number
// +optional
	shared_ptr< long long > lun; // `json:"lun,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Optional: FC volume world wide identifiers (wwids)
// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
// +optional
	vector< string > wwids; // `json:"wwids,omitempty"`
};
// Represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
struct ISCSIVolumeSource {
	ISCSIVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ISCSIVolumeSource & other) const;
	MARSHAL_JSON;
// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
// is other than default (typically TCP ports 860 and 3260).
	string targetPortal; // `json:"targetPortal"`
// Target iSCSI Qualified Name.
	string iqn; // `json:"iqn"`
// iSCSI Target Lun number.
	long long lun; // `json:"lun"`
// iSCSI Interface Name that uses an iSCSI transport.
// Defaults to 'default' (tcp).
// +optional
	string iscsiInterface; // `json:"iscsiInterface,omitempty"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// ReadOnly here will force the ReadOnly setting in VolumeMounts.
// Defaults to false.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
// is other than default (typically TCP ports 860 and 3260).
// +optional
	vector< string > portals; // `json:"portals,omitempty"`
// whether support iSCSI Discovery CHAP authentication
// +optional
	bool chapAuthDiscovery; // `json:"chapAuthDiscovery,omitempty"`
// whether support iSCSI Session CHAP authentication
// +optional
	bool chapAuthSession; // `json:"chapAuthSession,omitempty"`
// CHAP Secret for iSCSI target and initiator authentication
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
// Custom iSCSI Initiator Name.
// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
// <target portal>:<volume name> will be created for the connection.
// +optional
	shared_ptr< string > initiatorName; // `json:"initiatorName,omitempty"`
};
// Represents an NFS mount that lasts the lifetime of a pod.
// NFS volumes do not support ownership management or SELinux relabeling.
struct NFSVolumeSource {
	NFSVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const NFSVolumeSource & other) const;
	MARSHAL_JSON;
// Server is the hostname or IP address of the NFS server.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	string server; // `json:"server"`
// Path that is exported by the NFS server.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	string path; // `json:"path"`
// ReadOnly here will force
// the NFS export to be mounted with read-only permissions.
// Defaults to false.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Adapts a secret into a projected volume.
// 
// The contents of the target Secret's Data field will be presented in a
// projected volume as files using the keys in the Data field as the file names.
// Note that this is identical to a secret volume source without the default
// mode.
struct SecretProjection : public LocalObjectReference {
	SecretProjection();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretProjection & other) const;
	MARSHAL_JSON;
// If unspecified, each key-value pair in the Data field of the referenced
// Secret will be projected into the volume as a file whose name is the
// key and content is the value. If specified, the listed keys will be
// projected into the specified paths, and unlisted keys will not be
// present. If a key is specified which is not present in the Secret,
// the volume setup will error unless it is marked optional. Paths must be
// relative and may not contain the '..' path or start with '..'.
// +optional
	vector< KeyToPath > items; // `json:"items,omitempty"`
// Specify whether the Secret or its key must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// Projection that may be projected along with other supported volume types
struct VolumeProjection {
	VolumeProjection();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VolumeProjection & other) const;
	MARSHAL_JSON;
// all types below are the supported types for projection into the same volume
// information about the secret data to project
// +optional
	shared_ptr< SecretProjection > secret; // `json:"secret,omitempty"`
// information about the downwardAPI data to project
// +optional
	shared_ptr< DownwardAPIProjection > downwardAPI; // `json:"downwardAPI,omitempty"`
// information about the configMap data to project
// +optional
	shared_ptr< ConfigMapProjection > configMap; // `json:"configMap,omitempty"`
// information about the serviceAccountToken data to project
// +optional
	shared_ptr< ServiceAccountTokenProjection > serviceAccountToken; // `json:"serviceAccountToken,omitempty"`
};
// Represents a projected volume source
struct ProjectedVolumeSource {
	ProjectedVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ProjectedVolumeSource & other) const;
	MARSHAL_JSON;
// list of volume projections
	vector< VolumeProjection > sources; // `json:"sources"`
// Mode bits used to set permissions on created files by default.
// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
// Directories within the path are not affected by this setting.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > defaultMode; // `json:"defaultMode,omitempty"`
};
// Adapts a Secret into a volume.
// 
// The contents of the target Secret's Data field will be presented in a volume
// as files using the keys in the Data field as the file names.
// Secret volumes support ownership management and SELinux relabeling.
struct SecretVolumeSource {
	SecretVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretVolumeSource & other) const;
	MARSHAL_JSON;
// Name of the secret in the pod's namespace to use.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
// +optional
	string secretName; // `json:"secretName,omitempty"`
// If unspecified, each key-value pair in the Data field of the referenced
// Secret will be projected into the volume as a file whose name is the
// key and content is the value. If specified, the listed keys will be
// projected into the specified paths, and unlisted keys will not be
// present. If a key is specified which is not present in the Secret,
// the volume setup will error unless it is marked optional. Paths must be
// relative and may not contain the '..' path or start with '..'.
// +optional
	vector< KeyToPath > items; // `json:"items,omitempty"`
// Optional: mode bits used to set permissions on created files by default.
// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
// YAML accepts both octal and decimal values, JSON requires decimal values
// for mode bits. Defaults to 0644.
// Directories within the path are not affected by this setting.
// This might be in conflict with other options that affect the file
// mode, like fsGroup, and the result can be other mode bits set.
// +optional
	shared_ptr< long long > defaultMode; // `json:"defaultMode,omitempty"`
// Specify whether the Secret or its keys must be defined
// +optional
	shared_ptr< bool > optional; // `json:"optional,omitempty"`
};
// Represents a volume that is populated with the contents of a git repository.
// Git repo volumes do not support ownership management.
// Git repo volumes support SELinux relabeling.
// 
// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
// into the Pod's container.
struct GitRepoVolumeSource {
	GitRepoVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const GitRepoVolumeSource & other) const;
	MARSHAL_JSON;
// Repository URL
	string repository; // `json:"repository"`
// Commit hash for the specified revision.
// +optional
	string revision; // `json:"revision,omitempty"`
// Target directory name.
// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
// git repository.  Otherwise, if specified, the volume will contain the git repository in
// the subdirectory with the given name.
// +optional
	string directory; // `json:"directory,omitempty"`
};
// Represents a Persistent Disk resource in AWS.
// 
// An AWS EBS disk must exist before mounting to a container. The disk
// must also be in the same AWS zone as the kubelet. An AWS EBS disk
// can only be mounted as read/write once. AWS EBS volumes support
// ownership management and SELinux relabeling.
struct AWSElasticBlockStoreVolumeSource {
	AWSElasticBlockStoreVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const AWSElasticBlockStoreVolumeSource & other) const;
	MARSHAL_JSON;
// Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	string volumeID; // `json:"volumeID"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// The partition in the volume that you want to mount.
// If omitted, the default is to mount by volume name.
// Examples: For volume /dev/sda1, you specify the partition as "1".
// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
// +optional
	long long partition; // `json:"partition,omitempty"`
// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
// If omitted, the default is "false".
// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin.
struct FlexVolumeSource {
	FlexVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const FlexVolumeSource & other) const;
	MARSHAL_JSON;
// Driver is the name of the driver to use for this volume.
	string driver; // `json:"driver"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Optional: SecretRef is reference to the secret object containing
// sensitive information to pass to the plugin scripts. This may be
// empty if no secret object is specified. If the secret object
// contains more than one secret, all secrets are passed to the plugin
// scripts.
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Optional: Extra command options if any.
// +optional
	map< string , string > options; // `json:"options,omitempty"`
};
// Represents a Quobyte mount that lasts the lifetime of a pod.
// Quobyte volumes do not support ownership management or SELinux relabeling.
struct QuobyteVolumeSource {
	QuobyteVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const QuobyteVolumeSource & other) const;
	MARSHAL_JSON;
// Registry represents a single or multiple Quobyte Registry services
// specified as a string as host:port pair (multiple entries are separated with commas)
// which acts as the central registry for volumes
	string registry; // `json:"registry"`
// Volume is a string that references an already created Quobyte volume by name.
	string volume; // `json:"volume"`
// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
// Defaults to false.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// User to map volume access to
// Defaults to serivceaccount user
// +optional
	string user; // `json:"user,omitempty"`
// Group to map volume access to
// Default is no group
// +optional
	string group; // `json:"group,omitempty"`
// Tenant owning the given Quobyte volume in the Backend
// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
// +optional
	string tenant; // `json:"tenant,omitempty"`
};
// Represents a Persistent Disk resource in Google Compute Engine.
// 
// A GCE PD must exist before mounting to a container. The disk must
// also be in the same GCE project and zone as the kubelet. A GCE PD
// can only be mounted as read/write once or read-only many times. GCE
// PDs support ownership management and SELinux relabeling.
struct GCEPersistentDiskVolumeSource {
	GCEPersistentDiskVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const GCEPersistentDiskVolumeSource & other) const;
	MARSHAL_JSON;
// Unique name of the PD resource in GCE. Used to identify the disk in GCE.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	string pdName; // `json:"pdName"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// The partition in the volume that you want to mount.
// If omitted, the default is to mount by volume name.
// Examples: For volume /dev/sda1, you specify the partition as "1".
// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
// +optional
	long long partition; // `json:"partition,omitempty"`
// ReadOnly here will force the ReadOnly setting in VolumeMounts.
// Defaults to false.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a Flocker volume mounted by the Flocker agent.
// One and only one of datasetName and datasetUUID should be set.
// Flocker volumes do not support ownership management or SELinux relabeling.
struct FlockerVolumeSource {
	FlockerVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const FlockerVolumeSource & other) const;
	MARSHAL_JSON;
// Name of the dataset stored as metadata -> name on the dataset for Flocker
// should be considered as deprecated
// +optional
	string datasetName; // `json:"datasetName,omitempty"`
// UUID of the dataset. This is unique identifier of a Flocker dataset
// +optional
	string datasetUUID; // `json:"datasetUUID,omitempty"`
};
// SecretReference represents a Secret Reference. It has enough information to retrieve secret
// in any namespace
struct SecretReference {
	SecretReference();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const SecretReference & other) const;
	MARSHAL_JSON;
// Name is unique within a namespace to reference a secret resource.
// +optional
	string name; // `json:"name,omitempty"`
// Namespace defines the space within which the secret name must be unique.
// +optional
	string ns; // `json:"namespace,omitempty"`
};
// Represents storage that is managed by an external CSI volume driver (Beta feature)
struct CSIPersistentVolumeSource {
	CSIPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CSIPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// Driver is the name of the driver to use for this volume.
// Required.
	string driver; // `json:"driver"`
// VolumeHandle is the unique volume name returned by the CSI volume
// plugin’s CreateVolume to refer to the volume on all subsequent calls.
// Required.
	string volumeHandle; // `json:"volumeHandle"`
// Optional: The value to pass to ControllerPublishVolumeRequest.
// Defaults to false (read/write).
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs".
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Attributes of the volume to publish.
// +optional
	map< string , string > volumeAttributes; // `json:"volumeAttributes,omitempty"`
// ControllerPublishSecretRef is a reference to the secret object containing
// sensitive information to pass to the CSI driver to complete the CSI
// ControllerPublishVolume and ControllerUnpublishVolume calls.
// This field is optional, and may be empty if no secret is required. If the
// secret object contains more than one secret, all secrets are passed.
// +optional
	shared_ptr< SecretReference > controllerPublishSecretRef; // `json:"controllerPublishSecretRef,omitempty"`
// NodeStageSecretRef is a reference to the secret object containing sensitive
// information to pass to the CSI driver to complete the CSI NodeStageVolume
// and NodeStageVolume and NodeUnstageVolume calls.
// This field is optional, and may be empty if no secret is required. If the
// secret object contains more than one secret, all secrets are passed.
// +optional
	shared_ptr< SecretReference > nodeStageSecretRef; // `json:"nodeStageSecretRef,omitempty"`
// NodePublishSecretRef is a reference to the secret object containing
// sensitive information to pass to the CSI driver to complete the CSI
// NodePublishVolume and NodeUnpublishVolume calls.
// This field is optional, and may be empty if no secret is required. If the
// secret object contains more than one secret, all secrets are passed.
// +optional
	shared_ptr< SecretReference > nodePublishSecretRef; // `json:"nodePublishSecretRef,omitempty"`
// ControllerExpandSecretRef is a reference to the secret object containing
// sensitive information to pass to the CSI driver to complete the CSI
// ControllerExpandVolume call.
// This is an alpha field and requires enabling ExpandCSIVolumes feature gate.
// This field is optional, and may be empty if no secret is required. If the
// secret object contains more than one secret, all secrets are passed.
// +optional
	shared_ptr< SecretReference > controllerExpandSecretRef; // `json:"controllerExpandSecretRef,omitempty"`
};
// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
struct ScaleIOPersistentVolumeSource {
	ScaleIOPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ScaleIOPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// The host address of the ScaleIO API Gateway.
	string gateway; // `json:"gateway"`
// The name of the storage system as configured in ScaleIO.
	string system; // `json:"system"`
// SecretRef references to the secret for ScaleIO user and other
// sensitive information. If this is not provided, Login operation will fail.
	shared_ptr< SecretReference > secretRef; // `json:"secretRef"`
// Flag to enable/disable SSL communication with Gateway, default false
// +optional
	bool sslEnabled; // `json:"sslEnabled,omitempty"`
// The name of the ScaleIO Protection Domain for the configured storage.
// +optional
	string protectionDomain; // `json:"protectionDomain,omitempty"`
// The ScaleIO Storage Pool associated with the protection domain.
// +optional
	string storagePool; // `json:"storagePool,omitempty"`
// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
// Default is ThinProvisioned.
// +optional
	string storageMode; // `json:"storageMode,omitempty"`
// The name of a volume already created in the ScaleIO system
// that is associated with this volume source.
	string volumeName; // `json:"volumeName,omitempty"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs".
// Default is "xfs"
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// ISCSIPersistentVolumeSource represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
struct ISCSIPersistentVolumeSource {
	ISCSIPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ISCSIPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
// is other than default (typically TCP ports 860 and 3260).
	string targetPortal; // `json:"targetPortal"`
// Target iSCSI Qualified Name.
	string iqn; // `json:"iqn"`
// iSCSI Target Lun number.
	long long lun; // `json:"lun"`
// iSCSI Interface Name that uses an iSCSI transport.
// Defaults to 'default' (tcp).
// +optional
	string iscsiInterface; // `json:"iscsiInterface,omitempty"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// ReadOnly here will force the ReadOnly setting in VolumeMounts.
// Defaults to false.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
// is other than default (typically TCP ports 860 and 3260).
// +optional
	vector< string > portals; // `json:"portals,omitempty"`
// whether support iSCSI Discovery CHAP authentication
// +optional
	bool chapAuthDiscovery; // `json:"chapAuthDiscovery,omitempty"`
// whether support iSCSI Session CHAP authentication
// +optional
	bool chapAuthSession; // `json:"chapAuthSession,omitempty"`
// CHAP Secret for iSCSI target and initiator authentication
// +optional
	shared_ptr< SecretReference > secretRef; // `json:"secretRef,omitempty"`
// Custom iSCSI Initiator Name.
// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
// <target portal>:<volume name> will be created for the connection.
// +optional
	shared_ptr< string > initiatorName; // `json:"initiatorName,omitempty"`
};
// FlexPersistentVolumeSource represents a generic persistent volume resource that is
// provisioned/attached using an exec based plugin.
struct FlexPersistentVolumeSource {
	FlexPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const FlexPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// Driver is the name of the driver to use for this volume.
	string driver; // `json:"driver"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Optional: SecretRef is reference to the secret object containing
// sensitive information to pass to the plugin scripts. This may be
// empty if no secret object is specified. If the secret object
// contains more than one secret, all secrets are passed to the plugin
// scripts.
// +optional
	shared_ptr< SecretReference > secretRef; // `json:"secretRef,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Optional: Extra command options if any.
// +optional
	map< string , string > options; // `json:"options,omitempty"`
};
// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
struct CephFSPersistentVolumeSource {
	CephFSPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CephFSPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// Required: Monitors is a collection of Ceph monitors
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	vector< string > monitors; // `json:"monitors"`
// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
// +optional
	string path; // `json:"path,omitempty"`
// Optional: User is the rados user name, default is admin
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	string user; // `json:"user,omitempty"`
// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	string secretFile; // `json:"secretFile,omitempty"`
// Optional: SecretRef is reference to the authentication secret for User, default is empty.
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	shared_ptr< SecretReference > secretRef; // `json:"secretRef,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
struct CephFSVolumeSource {
	CephFSVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CephFSVolumeSource & other) const;
	MARSHAL_JSON;
// Required: Monitors is a collection of Ceph monitors
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
	vector< string > monitors; // `json:"monitors"`
// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
// +optional
	string path; // `json:"path,omitempty"`
// Optional: User is the rados user name, default is admin
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	string user; // `json:"user,omitempty"`
// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	string secretFile; // `json:"secretFile,omitempty"`
// Optional: SecretRef is reference to the authentication secret for User, default is empty.
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
struct CinderPersistentVolumeSource {
	CinderPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CinderPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// volume id used to identify the volume in cinder.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	string volumeID; // `json:"volumeID"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Optional: points to a secret object containing parameters used to connect
// to OpenStack.
// +optional
	shared_ptr< SecretReference > secretRef; // `json:"secretRef,omitempty"`
};
// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
struct CinderVolumeSource {
	CinderVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const CinderVolumeSource & other) const;
	MARSHAL_JSON;
// volume id used to identify the volume in cinder.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	string volumeID; // `json:"volumeID"`
// Filesystem type to mount.
// Must be a filesystem type supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	string fsType; // `json:"fsType,omitempty"`
// Optional: Defaults to false (read/write). ReadOnly here will force
// the ReadOnly setting in VolumeMounts.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// Optional: points to a secret object containing parameters used to connect
// to OpenStack.
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
};
// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
struct RBDPersistentVolumeSource {
	RBDPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const RBDPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// A collection of Ceph monitors.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	vector< string > monitors; // `json:"monitors"`
// The rados image name.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	string image; // `json:"image"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// The rados pool name.
// Default is rbd.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string pool; // `json:"pool,omitempty"`
// The rados user name.
// Default is admin.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string user; // `json:"user,omitempty"`
// Keyring is the path to key ring for RBDUser.
// Default is /etc/ceph/keyring.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string keyring; // `json:"keyring,omitempty"`
// SecretRef is name of the authentication secret for RBDUser. If provided
// overrides keyring.
// Default is nil.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	shared_ptr< SecretReference > secretRef; // `json:"secretRef,omitempty"`
// ReadOnly here will force the ReadOnly setting in VolumeMounts.
// Defaults to false.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
struct RBDVolumeSource {
	RBDVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const RBDVolumeSource & other) const;
	MARSHAL_JSON;
// A collection of Ceph monitors.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	vector< string > monitors; // `json:"monitors"`
// The rados image name.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
	string image; // `json:"image"`
// Filesystem type of the volume that you want to mount.
// Tip: Ensure that the filesystem type is supported by the host operating system.
// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
// TODO: how do we prevent errors in the filesystem from compromising the machine
// +optional
	string fsType; // `json:"fsType,omitempty"`
// The rados pool name.
// Default is rbd.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string pool; // `json:"pool,omitempty"`
// The rados user name.
// Default is admin.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string user; // `json:"user,omitempty"`
// Keyring is the path to key ring for RBDUser.
// Default is /etc/ceph/keyring.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	string keyring; // `json:"keyring,omitempty"`
// SecretRef is name of the authentication secret for RBDUser. If provided
// overrides keyring.
// Default is nil.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	shared_ptr< LocalObjectReference > secretRef; // `json:"secretRef,omitempty"`
// ReadOnly here will force the ReadOnly setting in VolumeMounts.
// Defaults to false.
// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
struct GlusterfsPersistentVolumeSource {
	GlusterfsPersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const GlusterfsPersistentVolumeSource & other) const;
	MARSHAL_JSON;
// EndpointsName is the endpoint name that details Glusterfs topology.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	string endpoints; // `json:"endpoints"`
// Path is the Glusterfs volume path.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	string path; // `json:"path"`
// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
// Defaults to false.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
// EndpointsNamespace is the namespace that contains Glusterfs endpoint.
// If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
// +optional
	shared_ptr< string > endpointsNamespace; // `json:"endpointsNamespace,omitempty"`
};
// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
struct GlusterfsVolumeSource {
	GlusterfsVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const GlusterfsVolumeSource & other) const;
	MARSHAL_JSON;
// EndpointsName is the endpoint name that details Glusterfs topology.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	string endpoints; // `json:"endpoints"`
// Path is the Glusterfs volume path.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
	string path; // `json:"path"`
// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
// Defaults to false.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents an empty directory for a pod.
// Empty directory volumes support ownership management and SELinux relabeling.
struct EmptyDirVolumeSource {
	EmptyDirVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EmptyDirVolumeSource & other) const;
	MARSHAL_JSON;
// What type of storage medium should back this directory.
// The default is "" which means to use the node's default medium.
// Must be an empty string (default) or Memory.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
// +optional
	StorageMedium medium; // `json:"medium,omitempty"`
// Total amount of local storage required for this EmptyDir volume.
// The size limit is also applicable for memory medium.
// The maximum usage on memory medium EmptyDir would be the minimum value between
// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
// The default is nil which means that the limit is undefined.
// More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
// +optional
	shared_ptr< apis::goraw::Quantity > sizeLimit; // `json:"sizeLimit,omitempty"`
};
// Represents a host path mapped into a pod.
// Host path volumes do not support ownership management or SELinux relabeling.
struct HostPathVolumeSource {
	HostPathVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const HostPathVolumeSource & other) const;
	MARSHAL_JSON;
// Path of the directory on the host.
// If the path is a symlink, it will follow the link to the real path.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	string path; // `json:"path"`
// Type for HostPath Volume
// Defaults to ""
// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
// +optional
	shared_ptr< HostPathType > type; // `json:"type,omitempty"`
};
// PersistentVolumeClaimCondition contails details about state of pvc
struct PersistentVolumeClaimCondition {
	PersistentVolumeClaimCondition();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimCondition & other) const;
	MARSHAL_JSON;
	PersistentVolumeClaimConditionType type; // `json:"type"`
	ConditionStatus status; // `json:"status"`
// Last time we probed the condition.
// +optional
	goraw::Time lastProbeTime; // `json:"lastProbeTime,omitempty"`
// Last time the condition transitioned from one status to another.
// +optional
	goraw::Time lastTransitionTime; // `json:"lastTransitionTime,omitempty"`
// Unique, this should be a short, machine understandable string that gives the reason
// for condition's last transition. If it reports "ResizeStarted" that means the underlying
// persistent volume is being resized.
// +optional
	string reason; // `json:"reason,omitempty"`
// Human-readable message indicating details about last transition.
// +optional
	string message; // `json:"message,omitempty"`
};
// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
struct PersistentVolumeClaimStatus {
	PersistentVolumeClaimStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimStatus & other) const;
	MARSHAL_JSON;
// Phase represents the current phase of PersistentVolumeClaim.
// +optional
	PersistentVolumeClaimPhase phase; // `json:"phase,omitempty"`
// AccessModes contains the actual access modes the volume backing the PVC has.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
// +optional
	vector< PersistentVolumeAccessMode > accessModes; // `json:"accessModes,omitempty"`
// Represents the actual resources of the underlying volume.
// +optional
	ResourceList capacity; // `json:"capacity,omitempty"`
// Current Condition of persistent volume claim. If underlying persistent volume is being
// resized then the Condition will be set to 'ResizeStarted'.
// +optional
// +patchMergeKey=type
// +patchStrategy=merge
	vector< PersistentVolumeClaimCondition > conditions; // `json:"conditions,omitempty"`
};
// PersistentVolumeClaimSpec describes the common attributes of storage devices
// and allows a Source for provider-specific attributes
struct PersistentVolumeClaimSpec {
	PersistentVolumeClaimSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimSpec & other) const;
	MARSHAL_JSON;
// AccessModes contains the desired access modes the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
// +optional
	vector< PersistentVolumeAccessMode > accessModes; // `json:"accessModes,omitempty"`
// A label query over volumes to consider for binding.
// +optional
	shared_ptr< apis::meta::v1::LabelSelector > selector; // `json:"selector,omitempty"`
// Resources represents the minimum resources the volume should have.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
// +optional
	ResourceRequirements resources; // `json:"resources,omitempty"`
// VolumeName is the binding reference to the PersistentVolume backing this claim.
// +optional
	string volumeName; // `json:"volumeName,omitempty"`
// Name of the StorageClass required by the claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
// +optional
	shared_ptr< string > storageClassName; // `json:"storageClassName,omitempty"`
// volumeMode defines what type of volume is required by the claim.
// Value of Filesystem is implied when not included in claim spec.
// +optional
	shared_ptr< PersistentVolumeMode > volumeMode; // `json:"volumeMode,omitempty"`
// This field can be used to specify either:
// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot - Beta)
// * An existing PVC (PersistentVolumeClaim)
// * An existing custom resource/object that implements data population (Alpha)
// In order to use VolumeSnapshot object types, the appropriate feature gate
// must be enabled (VolumeSnapshotDataSource or AnyVolumeDataSource)
// If the provisioner or an external controller can support the specified data source,
// it will create a new volume based on the contents of the specified data source.
// If the specified data source is not supported, the volume will
// not be created and the failure will be reported as an event.
// In the future, we plan to support more data source types and the behavior
// of the provisioner may change.
// +optional
	shared_ptr< TypedLocalObjectReference > dataSource; // `json:"dataSource,omitempty"`
};
// PersistentVolumeClaimTemplate is used to produce
// PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
struct PersistentVolumeClaimTemplate {
	PersistentVolumeClaimTemplate();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimTemplate & other) const;
	MARSHAL_JSON;
// May contain labels and annotations that will be copied into the PVC
// when creating it. No other fields are allowed and will be rejected during
// validation.
// 
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// The specification for the PersistentVolumeClaim. The entire content is
// copied unchanged into the PVC that gets created from this
// template. The same fields as in a PersistentVolumeClaim
// are also valid here.
	PersistentVolumeClaimSpec spec; // `json:"spec"`
};
// Represents an ephemeral volume that is handled by a normal storage driver.
struct EphemeralVolumeSource {
	EphemeralVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const EphemeralVolumeSource & other) const;
	MARSHAL_JSON;
// Will be used to create a stand-alone PVC to provision the volume.
// The pod in which this EphemeralVolumeSource is embedded will be the
// owner of the PVC, i.e. the PVC will be deleted together with the
// pod.  The name of the PVC will be `<pod name>-<volume name>` where
// `<volume name>` is the name from the `PodSpec.Volumes` array
// entry. Pod validation will reject the pod if the concatenated name
// is not valid for a PVC (for example, too long).
// 
// An existing PVC with that name that is not owned by the pod
// will *not* be used for the pod to avoid using an unrelated
// volume by mistake. Starting the pod is then blocked until
// the unrelated PVC is removed. If such a pre-created PVC is
// meant to be used by the pod, the PVC has to updated with an
// owner reference to the pod once the pod exists. Normally
// this should not be necessary, but it may be useful when
// manually reconstructing a broken cluster.
// 
// This field is read-only and no changes will be made by Kubernetes
// to the PVC after it has been created.
// 
// Required, must not be nil.
	shared_ptr< PersistentVolumeClaimTemplate > volumeClaimTemplate; // `json:"volumeClaimTemplate,omitempty"`
// Specifies a read-only configuration for the volume.
// Defaults to false (read/write).
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PersistentVolumeClaim is a user's request for and claim to a persistent volume
struct PersistentVolumeClaim : public apis::meta::v1::TypeMeta {
	PersistentVolumeClaim();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaim & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the desired characteristics of a volume requested by a pod author.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
// +optional
	PersistentVolumeClaimSpec spec; // `json:"spec,omitempty"`
// Status represents the current information/status of a persistent volume claim.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
// +optional
	PersistentVolumeClaimStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
struct PersistentVolumeClaimList : public apis::meta::v1::TypeMeta, public vector< PersistentVolumeClaim > {
	PersistentVolumeClaimList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// A list of persistent volume claims.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	vector< PersistentVolumeClaim > * items; // `json:"items"`
};
// PersistentVolumeStatus is the current status of a persistent volume.
struct PersistentVolumeStatus {
	PersistentVolumeStatus();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeStatus & other) const;
	MARSHAL_JSON;
// Phase indicates if a volume is available, bound to a claim, or released by a claim.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
// +optional
	PersistentVolumePhase phase; // `json:"phase,omitempty"`
// A human-readable message indicating details about why the volume is in this state.
// +optional
	string message; // `json:"message,omitempty"`
// Reason is a brief CamelCase string that describes any failure and is meant
// for machine parsing and tidy display in the CLI.
// +optional
	string reason; // `json:"reason,omitempty"`
};
// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
struct VolumeNodeAffinity {
	VolumeNodeAffinity();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VolumeNodeAffinity & other) const;
	MARSHAL_JSON;
// Required specifies hard node constraints that must be met.
	shared_ptr< NodeSelector > required; // `json:"required,omitempty"`
};
// PersistentVolumeSource is similar to VolumeSource but meant for the
// administrator who creates PVs. Exactly one of its members must be set.
struct PersistentVolumeSource {
	PersistentVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeSource & other) const;
	MARSHAL_JSON;
// GCEPersistentDisk represents a GCE Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
// +optional
	shared_ptr< GCEPersistentDiskVolumeSource > gcePersistentDisk; // `json:"gcePersistentDisk,omitempty"`
// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
// +optional
	shared_ptr< AWSElasticBlockStoreVolumeSource > awsElasticBlockStore; // `json:"awsElasticBlockStore,omitempty"`
// HostPath represents a directory on the host.
// Provisioned by a developer or tester.
// This is useful for single-node development and testing only!
// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
// +optional
	shared_ptr< HostPathVolumeSource > hostPath; // `json:"hostPath,omitempty"`
// Glusterfs represents a Glusterfs volume that is attached to a host and
// exposed to the pod. Provisioned by an admin.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md
// +optional
	shared_ptr< GlusterfsPersistentVolumeSource > glusterfs; // `json:"glusterfs,omitempty"`
// NFS represents an NFS mount on the host. Provisioned by an admin.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
// +optional
	shared_ptr< NFSVolumeSource > nfs; // `json:"nfs,omitempty"`
// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
// More info: https://examples.k8s.io/volumes/rbd/README.md
// +optional
	shared_ptr< RBDPersistentVolumeSource > rbd; // `json:"rbd,omitempty"`
// ISCSI represents an ISCSI Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
// +optional
	shared_ptr< ISCSIPersistentVolumeSource > iscsi; // `json:"iscsi,omitempty"`
// Cinder represents a cinder volume attached and mounted on kubelets host machine.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	shared_ptr< CinderPersistentVolumeSource > cinder; // `json:"cinder,omitempty"`
// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
// +optional
	shared_ptr< CephFSPersistentVolumeSource > cephfs; // `json:"cephfs,omitempty"`
// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
// +optional
	shared_ptr< FCVolumeSource > fc; // `json:"fc,omitempty"`
// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
// +optional
	shared_ptr< FlockerVolumeSource > flocker; // `json:"flocker,omitempty"`
// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin.
// +optional
	shared_ptr< FlexPersistentVolumeSource > flexVolume; // `json:"flexVolume,omitempty"`
// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
// +optional
	shared_ptr< AzureFilePersistentVolumeSource > azureFile; // `json:"azureFile,omitempty"`
// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
// +optional
	shared_ptr< VsphereVirtualDiskVolumeSource > vsphereVolume; // `json:"vsphereVolume,omitempty"`
// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
// +optional
	shared_ptr< QuobyteVolumeSource > quobyte; // `json:"quobyte,omitempty"`
// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
// +optional
	shared_ptr< AzureDiskVolumeSource > azureDisk; // `json:"azureDisk,omitempty"`
// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
	shared_ptr< PhotonPersistentDiskVolumeSource > photonPersistentDisk; // `json:"photonPersistentDisk,omitempty"`
// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
// +optional
	shared_ptr< PortworxVolumeSource > portworxVolume; // `json:"portworxVolume,omitempty"`
// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
// +optional
	shared_ptr< ScaleIOPersistentVolumeSource > scaleIO; // `json:"scaleIO,omitempty"`
// Local represents directly-attached storage with node affinity
// +optional
	shared_ptr< LocalVolumeSource > local; // `json:"local,omitempty"`
// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
// More info: https://examples.k8s.io/volumes/storageos/README.md
// +optional
	shared_ptr< StorageOSPersistentVolumeSource > storageos; // `json:"storageos,omitempty"`
// CSI represents storage that is handled by an external CSI driver (Beta feature).
// +optional
	shared_ptr< CSIPersistentVolumeSource > csi; // `json:"csi,omitempty"`
};
// PersistentVolumeSpec is the specification of a persistent volume.
struct PersistentVolumeSpec : public PersistentVolumeSource {
	PersistentVolumeSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeSpec & other) const;
	MARSHAL_JSON;
// A description of the persistent volume's resources and capacity.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
// +optional
	ResourceList capacity; // `json:"capacity,omitempty"`
// AccessModes contains all ways the volume can be mounted.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
// +optional
	vector< PersistentVolumeAccessMode > accessModes; // `json:"accessModes,omitempty"`
// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
// Expected to be non-nil when bound.
// claim.VolumeName is the authoritative bind between PV and PVC.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
// +optional
	shared_ptr< ObjectReference > claimRef; // `json:"claimRef,omitempty"`
// What happens to a persistent volume when released from its claim.
// Valid options are Retain (default for manually created PersistentVolumes), Delete (default
// for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
// Recycle must be supported by the volume plugin underlying this PersistentVolume.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
// +optional
	PersistentVolumeReclaimPolicy persistentVolumeReclaimPolicy; // `json:"persistentVolumeReclaimPolicy,omitempty"`
// Name of StorageClass to which this persistent volume belongs. Empty value
// means that this volume does not belong to any StorageClass.
// +optional
	string storageClassName; // `json:"storageClassName,omitempty"`
// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
// simply fail if one is invalid.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
// +optional
	vector< string > mountOptions; // `json:"mountOptions,omitempty"`
// volumeMode defines if a volume is intended to be used with a formatted filesystem
// or to remain in raw block state. Value of Filesystem is implied when not included in spec.
// +optional
	shared_ptr< PersistentVolumeMode > volumeMode; // `json:"volumeMode,omitempty"`
// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
// This field influences the scheduling of pods that use this volume.
// +optional
	shared_ptr< VolumeNodeAffinity > nodeAffinity; // `json:"nodeAffinity,omitempty"`
};
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PersistentVolume (PV) is a storage resource provisioned by an administrator.
// It is analogous to a node.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
struct PersistentVolume : public apis::meta::v1::TypeMeta {
	PersistentVolume();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolume & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines a specification of a persistent volume owned by the cluster.
// Provisioned by an administrator.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
// +optional
	PersistentVolumeSpec spec; // `json:"spec,omitempty"`
// Status represents the current information/status for the persistent volume.
// Populated by the system.
// Read-only.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
// +optional
	PersistentVolumeStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PersistentVolumeList is a list of PersistentVolume items.
struct PersistentVolumeList : public apis::meta::v1::TypeMeta, public vector< PersistentVolume > {
	PersistentVolumeList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of persistent volumes.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
	vector< PersistentVolume > * items; // `json:"items"`
};
// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
// This volume finds the bound PV and mounts that volume for the pod. A
// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
// type of volume that is owned by someone else (the system).
struct PersistentVolumeClaimVolumeSource {
	PersistentVolumeClaimVolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PersistentVolumeClaimVolumeSource & other) const;
	MARSHAL_JSON;
// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	string claimName; // `json:"claimName"`
// Will force the ReadOnly setting in VolumeMounts.
// Default false.
// +optional
	bool readOnly; // `json:"readOnly,omitempty"`
};
// Represents the source of a volume to mount.
// Only one of its members may be specified.
struct VolumeSource {
	VolumeSource();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const VolumeSource & other) const;
	MARSHAL_JSON;
// HostPath represents a pre-existing file or directory on the host
// machine that is directly exposed to the container. This is generally
// used for system agents or other privileged things that are allowed
// to see the host machine. Most containers will NOT need this.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
// ---
// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
// mount host directories as read/write.
// +optional
	shared_ptr< HostPathVolumeSource > hostPath; // `json:"hostPath,omitempty"`
// EmptyDir represents a temporary directory that shares a pod's lifetime.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
// +optional
	shared_ptr< EmptyDirVolumeSource > emptyDir; // `json:"emptyDir,omitempty"`
// GCEPersistentDisk represents a GCE Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
// +optional
	shared_ptr< GCEPersistentDiskVolumeSource > gcePersistentDisk; // `json:"gcePersistentDisk,omitempty"`
// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
// +optional
	shared_ptr< AWSElasticBlockStoreVolumeSource > awsElasticBlockStore; // `json:"awsElasticBlockStore,omitempty"`
// GitRepo represents a git repository at a particular revision.
// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
// into the Pod's container.
// +optional
	shared_ptr< GitRepoVolumeSource > gitRepo; // `json:"gitRepo,omitempty"`
// Secret represents a secret that should populate this volume.
// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
// +optional
	shared_ptr< SecretVolumeSource > secret; // `json:"secret,omitempty"`
// NFS represents an NFS mount on the host that shares a pod's lifetime
// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
// +optional
	shared_ptr< NFSVolumeSource > nfs; // `json:"nfs,omitempty"`
// ISCSI represents an ISCSI Disk resource that is attached to a
// kubelet's host machine and then exposed to the pod.
// More info: https://examples.k8s.io/volumes/iscsi/README.md
// +optional
	shared_ptr< ISCSIVolumeSource > iscsi; // `json:"iscsi,omitempty"`
// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
// More info: https://examples.k8s.io/volumes/glusterfs/README.md
// +optional
	shared_ptr< GlusterfsVolumeSource > glusterfs; // `json:"glusterfs,omitempty"`
// PersistentVolumeClaimVolumeSource represents a reference to a
// PersistentVolumeClaim in the same namespace.
// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
// +optional
	shared_ptr< PersistentVolumeClaimVolumeSource > persistentVolumeClaim; // `json:"persistentVolumeClaim,omitempty"`
// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
// More info: https://examples.k8s.io/volumes/rbd/README.md
// +optional
	shared_ptr< RBDVolumeSource > rbd; // `json:"rbd,omitempty"`
// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin.
// +optional
	shared_ptr< FlexVolumeSource > flexVolume; // `json:"flexVolume,omitempty"`
// Cinder represents a cinder volume attached and mounted on kubelets host machine.
// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
// +optional
	shared_ptr< CinderVolumeSource > cinder; // `json:"cinder,omitempty"`
// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
// +optional
	shared_ptr< CephFSVolumeSource > cephfs; // `json:"cephfs,omitempty"`
// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
// +optional
	shared_ptr< FlockerVolumeSource > flocker; // `json:"flocker,omitempty"`
// DownwardAPI represents downward API about the pod that should populate this volume
// +optional
	shared_ptr< DownwardAPIVolumeSource > downwardAPI; // `json:"downwardAPI,omitempty"`
// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
// +optional
	shared_ptr< FCVolumeSource > fc; // `json:"fc,omitempty"`
// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
// +optional
	shared_ptr< AzureFileVolumeSource > azureFile; // `json:"azureFile,omitempty"`
// ConfigMap represents a configMap that should populate this volume
// +optional
	shared_ptr< ConfigMapVolumeSource > configMap; // `json:"configMap,omitempty"`
// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
// +optional
	shared_ptr< VsphereVirtualDiskVolumeSource > vsphereVolume; // `json:"vsphereVolume,omitempty"`
// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
// +optional
	shared_ptr< QuobyteVolumeSource > quobyte; // `json:"quobyte,omitempty"`
// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
// +optional
	shared_ptr< AzureDiskVolumeSource > azureDisk; // `json:"azureDisk,omitempty"`
// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
	shared_ptr< PhotonPersistentDiskVolumeSource > photonPersistentDisk; // `json:"photonPersistentDisk,omitempty"`
// Items for all in one resources secrets, configmaps, and downward API
	shared_ptr< ProjectedVolumeSource > projected; // `json:"projected,omitempty"`
// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
// +optional
	shared_ptr< PortworxVolumeSource > portworxVolume; // `json:"portworxVolume,omitempty"`
// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
// +optional
	shared_ptr< ScaleIOVolumeSource > scaleIO; // `json:"scaleIO,omitempty"`
// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
// +optional
	shared_ptr< StorageOSVolumeSource > storageos; // `json:"storageos,omitempty"`
// CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
// +optional
	shared_ptr< CSIVolumeSource > csi; // `json:"csi,omitempty"`
// Ephemeral represents a volume that is handled by a cluster storage driver (Alpha feature).
// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
// and deleted when the pod is removed.
// 
// Use this if:
// a) the volume is only needed while the pod runs,
// b) features of normal volumes like restoring from snapshot or capacity
// tracking are needed,
// c) the storage driver is specified through a storage class, and
// d) the storage driver supports dynamic volume provisioning through
// a PersistentVolumeClaim (see EphemeralVolumeSource for more
// information on the connection between this volume type
// and PersistentVolumeClaim).
// 
// Use PersistentVolumeClaim or one of the vendor-specific
// APIs for volumes that persist for longer than the lifecycle
// of an individual pod.
// 
// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
// be used that way - see the documentation of the driver for
// more information.
// 
// A pod can use both types of ephemeral volumes and
// persistent volumes at the same time.
// 
// +optional
	shared_ptr< EphemeralVolumeSource > ephemeral; // `json:"ephemeral,omitempty"`
};
// TopologyKeyAny is the service topology key that matches any node
// Volume represents a named volume in a pod that may be accessed by any container in the pod.
struct Volume : public VolumeSource {
	Volume();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Volume & other) const;
	MARSHAL_JSON;
// Volume's name.
// Must be a DNS_LABEL and unique within the pod.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	string name; // `json:"name"`
};
// PodSpec is a description of a pod.
struct PodSpec {
	PodSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodSpec & other) const;
	MARSHAL_JSON;
// List of volumes that can be mounted by containers belonging to the pod.
// More info: https://kubernetes.io/docs/concepts/storage/volumes
// +optional
// +patchMergeKey=name
// +patchStrategy=merge,retainKeys
	vector< Volume > volumes; // `json:"volumes,omitempty"`
// List of initialization containers belonging to the pod.
// Init containers are executed in order prior to containers being started. If any
// init container fails, the pod is considered to have failed and is handled according
// to its restartPolicy. The name for an init container or normal container must be
// unique among all containers.
// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
// The resourceRequirements of an init container are taken into account during scheduling
// by finding the highest request/limit for each resource type, and then using the max of
// of that value or the sum of the normal containers. Limits are applied to init containers
// in a similar fashion.
// Init containers cannot currently be added or removed.
// Cannot be updated.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
// +patchMergeKey=name
// +patchStrategy=merge
	vector< Container > initContainers; // `json:"initContainers,omitempty"`
// List of containers belonging to the pod.
// Containers cannot currently be added or removed.
// There must be at least one container in a Pod.
// Cannot be updated.
// +patchMergeKey=name
// +patchStrategy=merge
	vector< Container > containers; // `json:"containers"`
// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
// pod to perform user-initiated actions such as debugging. This list cannot be specified when
// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.
// +optional
// +patchMergeKey=name
// +patchStrategy=merge
	vector< EphemeralContainer > ephemeralContainers; // `json:"ephemeralContainers,omitempty"`
// Restart policy for all containers within the pod.
// One of Always, OnFailure, Never.
// Default to Always.
// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
// +optional
	RestartPolicy restartPolicy; // `json:"restartPolicy,omitempty"`
// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
// Value must be non-negative integer. The value zero indicates delete immediately.
// If this value is nil, the default grace period will be used instead.
// The grace period is the duration in seconds after the processes running in the pod are sent
// a termination signal and the time when the processes are forcibly halted with a kill signal.
// Set this value longer than the expected cleanup time for your process.
// Defaults to 30 seconds.
// +optional
	shared_ptr< long long > terminationGracePeriodSeconds; // `json:"terminationGracePeriodSeconds,omitempty"`
// Optional duration in seconds the pod may be active on the node relative to
// StartTime before the system will actively try to mark it failed and kill associated containers.
// Value must be a positive integer.
// +optional
	shared_ptr< long long > activeDeadlineSeconds; // `json:"activeDeadlineSeconds,omitempty"`
// Set DNS policy for the pod.
// Defaults to "ClusterFirst".
// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
// To have DNS options set along with hostNetwork, you have to specify DNS policy
// explicitly to 'ClusterFirstWithHostNet'.
// +optional
	DNSPolicy dnsPolicy; // `json:"dnsPolicy,omitempty"`
// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
// +optional
	map< string , string > nodeSelector; // `json:"nodeSelector,omitempty"`
// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
// +optional
	string serviceAccountName; // `json:"serviceAccountName,omitempty"`
// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
// Deprecated: Use serviceAccountName instead.
// +k8s:conversion-gen=false
// +optional
	string serviceAccount; // `json:"serviceAccount,omitempty"`
// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
// +optional
	shared_ptr< bool > automountServiceAccountToken; // `json:"automountServiceAccountToken,omitempty"`
// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
// the scheduler simply schedules this pod onto that node, assuming that it fits resource
// requirements.
// +optional
	string nodeName; // `json:"nodeName,omitempty"`
// Host networking requested for this pod. Use the host's network namespace.
// If this option is set, the ports that will be used must be specified.
// Default to false.
// +k8s:conversion-gen=false
// +optional
	bool hostNetwork; // `json:"hostNetwork,omitempty"`
// Use the host's pid namespace.
// Optional: Default to false.
// +k8s:conversion-gen=false
// +optional
	bool hostPID; // `json:"hostPID,omitempty"`
// Use the host's ipc namespace.
// Optional: Default to false.
// +k8s:conversion-gen=false
// +optional
	bool hostIPC; // `json:"hostIPC,omitempty"`
// Share a single process namespace between all of the containers in a pod.
// When this is set containers will be able to view and signal processes from other containers
// in the same pod, and the first process in each container will not be assigned PID 1.
// HostPID and ShareProcessNamespace cannot both be set.
// Optional: Default to false.
// +k8s:conversion-gen=false
// +optional
	shared_ptr< bool > shareProcessNamespace; // `json:"shareProcessNamespace,omitempty"`
// SecurityContext holds pod-level security attributes and common container settings.
// Optional: Defaults to empty.  See type description for default values of each field.
// +optional
	shared_ptr< PodSecurityContext > securityContext; // `json:"securityContext,omitempty"`
// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
// in the case of docker, only DockerConfig type secrets are honored.
// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
// +optional
// +patchMergeKey=name
// +patchStrategy=merge
	vector< LocalObjectReference > imagePullSecrets; // `json:"imagePullSecrets,omitempty"`
// Specifies the hostname of the Pod
// If not specified, the pod's hostname will be set to a system-defined value.
// +optional
	string hostname; // `json:"hostname,omitempty"`
// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
// If not specified, the pod will not have a domainname at all.
// +optional
	string subdomain; // `json:"subdomain,omitempty"`
// If specified, the pod's scheduling constraints
// +optional
	shared_ptr< Affinity > affinity; // `json:"affinity,omitempty"`
// If specified, the pod will be dispatched by specified scheduler.
// If not specified, the pod will be dispatched by default scheduler.
// +optional
	string schedulerName; // `json:"schedulerName,omitempty"`
// If specified, the pod's tolerations.
// +optional
	vector< Toleration > tolerations; // `json:"tolerations,omitempty"`
// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
// file if specified. This is only valid for non-hostNetwork pods.
// +optional
// +patchMergeKey=ip
// +patchStrategy=merge
	vector< HostAlias > hostAliases; // `json:"hostAliases,omitempty"`
// If specified, indicates the pod's priority. "system-node-critical" and
// "system-cluster-critical" are two special keywords which indicate the
// highest priorities with the former being the highest priority. Any other
// name must be defined by creating a PriorityClass object with that name.
// If not specified, the pod priority will be default or zero if there is no
// default.
// +optional
	string priorityClassName; // `json:"priorityClassName,omitempty"`
// The priority value. Various system components use this field to find the
// priority of the pod. When Priority Admission Controller is enabled, it
// prevents users from setting this field. The admission controller populates
// this field from PriorityClassName.
// The higher the value, the higher the priority.
// +optional
	shared_ptr< long long > priority; // `json:"priority,omitempty"`
// Specifies the DNS parameters of a pod.
// Parameters specified here will be merged to the generated DNS
// configuration based on DNSPolicy.
// +optional
	shared_ptr< PodDNSConfig > dnsConfig; // `json:"dnsConfig,omitempty"`
// If specified, all readiness gates will be evaluated for pod readiness.
// A pod is ready when all its containers are ready AND
// all conditions specified in the readiness gates have status equal to "True"
// More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
// +optional
	vector< PodReadinessGate > readinessGates; // `json:"readinessGates,omitempty"`
// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
// empty definition that uses the default runtime handler.
// More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
// This is a beta feature as of Kubernetes v1.14.
// +optional
	shared_ptr< string > runtimeClassName; // `json:"runtimeClassName,omitempty"`
// EnableServiceLinks indicates whether information about services should be injected into pod's
// environment variables, matching the syntax of Docker links.
// Optional: Defaults to true.
// +optional
	shared_ptr< bool > enableServiceLinks; // `json:"enableServiceLinks,omitempty"`
// PreemptionPolicy is the Policy for preempting pods with lower priority.
// One of Never, PreemptLowerPriority.
// Defaults to PreemptLowerPriority if unset.
// This field is beta-level, gated by the NonPreemptingPriority feature-gate.
// +optional
	shared_ptr< PreemptionPolicy > preemptionPolicy; // `json:"preemptionPolicy,omitempty"`
// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
// More info: https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md
// This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable the PodOverhead feature.
// +optional
	ResourceList overhead; // `json:"overhead,omitempty"`
// TopologySpreadConstraints describes how a group of pods ought to spread across topology
// domains. Scheduler will schedule pods in a way which abides by the constraints.
// All topologySpreadConstraints are ANDed.
// +optional
// +patchMergeKey=topologyKey
// +patchStrategy=merge
// +listType=map
// +listMapKey=topologyKey
// +listMapKey=whenUnsatisfiable
	vector< TopologySpreadConstraint > topologySpreadConstraints; // `json:"topologySpreadConstraints,omitempty"`
// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
// If a pod does not have FQDN, this has no effect.
// Default to false.
// +optional
	shared_ptr< bool > setHostnameAsFQDN; // `json:"setHostnameAsFQDN,omitempty"`
};
// PodTemplateSpec describes the data a pod should have when created from a template
struct PodTemplateSpec {
	PodTemplateSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodTemplateSpec & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Specification of the desired behavior of the pod.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	PodSpec spec; // `json:"spec,omitempty"`
};
// ReplicationControllerSpec is the specification of a replication controller.
struct ReplicationControllerSpec {
	ReplicationControllerSpec();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ReplicationControllerSpec & other) const;
	MARSHAL_JSON;
// Replicas is the number of desired replicas.
// This is a pointer to distinguish between explicit zero and unspecified.
// Defaults to 1.
// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
// +optional
	shared_ptr< long long > replicas; // `json:"replicas,omitempty"`
// Minimum number of seconds for which a newly created pod should be ready
// without any of its container crashing, for it to be considered available.
// Defaults to 0 (pod will be considered available as soon as it is ready)
// +optional
	long long minReadySeconds; // `json:"minReadySeconds,omitempty"`
// Selector is a label query over pods that should match the Replicas count.
// If Selector is empty, it is defaulted to the labels present on the Pod template.
// Label keys and values that must match in order to be controlled by this replication
// controller, if empty defaulted to labels on Pod template.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
// +optional
	map< string , string > selector; // `json:"selector,omitempty"`
// TemplateRef is a reference to an object that describes the pod that will be created if
// insufficient replicas are detected.
// Reference to an object that describes the pod that will be created if insufficient replicas are detected.
// +optional
// TemplateRef *ObjectReference `json:"templateRef,omitempty"`
// Template is the object that describes the pod that will be created if
// insufficient replicas are detected. This takes precedence over a TemplateRef.
// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
// +optional
	shared_ptr< PodTemplateSpec > Template; // `json:"template,omitempty"`
};
// +genclient
// +genclient:method=GetScale,verb=get,subresource=scale,result=k8s.io/api/autoscaling/v1.Scale
// +genclient:method=UpdateScale,verb=update,subresource=scale,input=k8s.io/api/autoscaling/v1.Scale,result=k8s.io/api/autoscaling/v1.Scale
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ReplicationController represents the configuration of a replication controller.
struct ReplicationController : public apis::meta::v1::TypeMeta {
	ReplicationController();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ReplicationController & other) const;
	MARSHAL_JSON;
// If the Labels of a ReplicationController are empty, they are defaulted to
// be the same as the Pod(s) that the replication controller manages.
// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Spec defines the specification of the desired behavior of the replication controller.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ReplicationControllerSpec spec; // `json:"spec,omitempty"`
// Status is the most recently observed status of the replication controller.
// This data may be out of date by some window of time.
// Populated by the system.
// Read-only.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	ReplicationControllerStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ReplicationControllerList is a collection of replication controllers.
struct ReplicationControllerList : public apis::meta::v1::TypeMeta, public vector< ReplicationController > {
	ReplicationControllerList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const ReplicationControllerList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of replication controllers.
// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
	vector< ReplicationController > * items; // `json:"items"`
};
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodTemplate describes a template for creating copies of a predefined pod.
struct PodTemplate : public apis::meta::v1::TypeMeta {
	PodTemplate();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodTemplate & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Template defines the pods that will be created from this pod template.
// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	PodTemplateSpec Template; // `json:"template,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodTemplateList is a list of PodTemplates.
struct PodTemplateList : public apis::meta::v1::TypeMeta, public vector< PodTemplate > {
	PodTemplateList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodTemplateList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of pod templates
	vector< PodTemplate > * items; // `json:"items"`
};
// +genclient
// +genclient:method=GetEphemeralContainers,verb=get,subresource=ephemeralcontainers,result=EphemeralContainers
// +genclient:method=UpdateEphemeralContainers,verb=update,subresource=ephemeralcontainers,input=EphemeralContainers,result=EphemeralContainers
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// Pod is a collection of containers that can run on a host. This resource is created
// by clients and scheduled onto hosts.
struct Pod : public apis::meta::v1::TypeMeta {
	Pod();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const Pod & other) const;
	MARSHAL_JSON;
// Standard object's metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
// +optional
	apis::meta::v1::ObjectMeta metadata; // `json:"metadata,omitempty"`
// Specification of the desired behavior of the pod.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	PodSpec spec; // `json:"spec,omitempty"`
// Most recently observed status of the pod.
// This data may not be up to date.
// Populated by the system.
// Read-only.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +optional
	PodStatus status; // `json:"status,omitempty"`
};
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// PodList is a list of Pods.
struct PodList : public apis::meta::v1::TypeMeta, public vector< Pod > {
	PodList();
	static string getGroupVersion(bool group = true, bool version = true);
	static string getResName(bool lower = false, bool multi = false);
	void inspect(const string & name = "", unsigned level = 0) const;
	bool operator==(const PodList & other) const;
	MARSHAL_JSON;
// Standard list metadata.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
// +optional
	apis::meta::v1::ListMeta metadata; // `json:"metadata,omitempty"`
// List of pods.
// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	vector< Pod > * items; // `json:"items"`
};
}}}

#endif /* end of include guard: TYPES_H_0200D91C */
